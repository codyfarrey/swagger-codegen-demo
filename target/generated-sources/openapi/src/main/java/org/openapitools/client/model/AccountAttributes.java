/*
 * IB REST API
 * The IB REST API reference documentation
 *
 * The version of the OpenAPI document: 2.13.0
 * Contact: api@interactivebrokers.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AccountAttributesParent;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * AccountAttributes
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-03-18T20:44:00.611784800-05:00[America/Chicago]", comments = "Generator version: 7.12.0")
public class AccountAttributes {
  public static final String SERIALIZED_NAME_ACCOUNT_ALIAS = "accountAlias";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_ALIAS)
  @javax.annotation.Nullable
  private String accountAlias;

  public static final String SERIALIZED_NAME_ACCOUNT_STATUS = "accountStatus";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_STATUS)
  @javax.annotation.Nullable
  private Integer accountStatus;

  public static final String SERIALIZED_NAME_ACCOUNT_TITLE = "accountTitle";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_TITLE)
  @javax.annotation.Nullable
  private String accountTitle;

  public static final String SERIALIZED_NAME_ACCOUNT_VAN = "accountVan";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_VAN)
  @javax.annotation.Nullable
  private String accountVan;

  public static final String SERIALIZED_NAME_ACCT_CUST_TYPE = "acctCustType";
  @SerializedName(SERIALIZED_NAME_ACCT_CUST_TYPE)
  @javax.annotation.Nullable
  private String acctCustType;

  public static final String SERIALIZED_NAME_BROKERAGE_ACCESS = "brokerageAccess";
  @SerializedName(SERIALIZED_NAME_BROKERAGE_ACCESS)
  @javax.annotation.Nullable
  private Boolean brokerageAccess;

  /**
   * A descriptor of the nature of the account, reflecting the responsible group within IB.
   */
  @JsonAdapter(BusinessTypeEnum.Adapter.class)
  public enum BusinessTypeEnum {
    IB_SALES("IB_SALES"),
    
    IB_PROSERVE("IB_PROSERVE");

    private String value;

    BusinessTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BusinessTypeEnum fromValue(String value) {
      for (BusinessTypeEnum b : BusinessTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<BusinessTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BusinessTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BusinessTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return BusinessTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      BusinessTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_BUSINESS_TYPE = "businessType";
  @SerializedName(SERIALIZED_NAME_BUSINESS_TYPE)
  @javax.annotation.Nullable
  private BusinessTypeEnum businessType;

  /**
   * Status of the account with respect to clearing at IB. O is open, P pending, N new, A abandoned, C closed, R rejected.
   */
  @JsonAdapter(ClearingStatusEnum.Adapter.class)
  public enum ClearingStatusEnum {
    O("O"),
    
    P("P"),
    
    N("N"),
    
    A("A"),
    
    R("R"),
    
    C("C");

    private String value;

    ClearingStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ClearingStatusEnum fromValue(String value) {
      for (ClearingStatusEnum b : ClearingStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ClearingStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ClearingStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ClearingStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ClearingStatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ClearingStatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CLEARING_STATUS = "clearingStatus";
  @SerializedName(SERIALIZED_NAME_CLEARING_STATUS)
  @javax.annotation.Nullable
  private ClearingStatusEnum clearingStatus;

  public static final String SERIALIZED_NAME_COVESTOR = "covestor";
  @SerializedName(SERIALIZED_NAME_COVESTOR)
  @javax.annotation.Nullable
  private Boolean covestor;

  /**
   * Base currency of the account.
   */
  @JsonAdapter(CurrencyEnum.Adapter.class)
  public enum CurrencyEnum {
    USD("USD");

    private String value;

    CurrencyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CurrencyEnum fromValue(String value) {
      for (CurrencyEnum b : CurrencyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CurrencyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CurrencyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CurrencyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CurrencyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CurrencyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  @javax.annotation.Nullable
  private CurrencyEnum currency;

  public static final String SERIALIZED_NAME_DESC = "desc";
  @SerializedName(SERIALIZED_NAME_DESC)
  @javax.annotation.Nullable
  private String desc;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  @javax.annotation.Nullable
  private String displayName;

  public static final String SERIALIZED_NAME_FA_CLIENT = "faClient";
  @SerializedName(SERIALIZED_NAME_FA_CLIENT)
  @javax.annotation.Nullable
  private Boolean faClient;

  /**
   * IB business entity under which the account resides.
   */
  @JsonAdapter(IbEntityEnum.Adapter.class)
  public enum IbEntityEnum {
    IBLLC_US("IBLLC-US"),
    
    IB_CAN("IB-CAN"),
    
    IB_UK("IB-UK"),
    
    IB_IE("IB-IE");

    private String value;

    IbEntityEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IbEntityEnum fromValue(String value) {
      for (IbEntityEnum b : IbEntityEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<IbEntityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IbEntityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IbEntityEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return IbEntityEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      IbEntityEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_IB_ENTITY = "ibEntity";
  @SerializedName(SERIALIZED_NAME_IB_ENTITY)
  @javax.annotation.Nullable
  private IbEntityEnum ibEntity;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_NO_CLIENT_TRADING = "noClientTrading";
  @SerializedName(SERIALIZED_NAME_NO_CLIENT_TRADING)
  @javax.annotation.Nullable
  private Boolean noClientTrading;

  public static final String SERIALIZED_NAME_PARENT = "parent";
  @SerializedName(SERIALIZED_NAME_PARENT)
  @javax.annotation.Nullable
  private AccountAttributesParent parent;

  public static final String SERIALIZED_NAME_PREPAID_CRYPTO_P = "PrepaidCrypto-P";
  @SerializedName(SERIALIZED_NAME_PREPAID_CRYPTO_P)
  @javax.annotation.Nullable
  private Boolean prepaidCryptoP;

  public static final String SERIALIZED_NAME_PREPAID_CRYPTO_Z = "PrepaidCrypto-Z";
  @SerializedName(SERIALIZED_NAME_PREPAID_CRYPTO_Z)
  @javax.annotation.Nullable
  private Boolean prepaidCryptoZ;

  public static final String SERIALIZED_NAME_TRACK_VIRTUAL_F_X_PORTFOLIO = "trackVirtualFXPortfolio";
  @SerializedName(SERIALIZED_NAME_TRACK_VIRTUAL_F_X_PORTFOLIO)
  @javax.annotation.Nullable
  private Boolean trackVirtualFXPortfolio;

  /**
   * Internal identifier used by IB to reflect the trading permissions of the account.
   */
  @JsonAdapter(TradingTypeEnum.Adapter.class)
  public enum TradingTypeEnum {
    STKNOPT("STKNOPT");

    private String value;

    TradingTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TradingTypeEnum fromValue(String value) {
      for (TradingTypeEnum b : TradingTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TradingTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TradingTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TradingTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TradingTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TradingTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TRADING_TYPE = "tradingType";
  @SerializedName(SERIALIZED_NAME_TRADING_TYPE)
  @javax.annotation.Nullable
  private TradingTypeEnum tradingType;

  /**
   * Indicates whether the account exists in production, paper, or demo environments.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    DEMO("DEMO");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  @javax.annotation.Nullable
  private TypeEnum type;

  public AccountAttributes() {
  }

  public AccountAttributes accountAlias(@javax.annotation.Nullable String accountAlias) {
    this.accountAlias = accountAlias;
    return this;
  }

  /**
   * User-defined alias assigned to the account for easy identification.
   * @return accountAlias
   */
  @javax.annotation.Nullable
  public String getAccountAlias() {
    return accountAlias;
  }

  public void setAccountAlias(@javax.annotation.Nullable String accountAlias) {
    this.accountAlias = accountAlias;
  }


  public AccountAttributes accountStatus(@javax.annotation.Nullable Integer accountStatus) {
    this.accountStatus = accountStatus;
    return this;
  }

  /**
   * Unix epoch timestamp of account opening.
   * @return accountStatus
   */
  @javax.annotation.Nullable
  public Integer getAccountStatus() {
    return accountStatus;
  }

  public void setAccountStatus(@javax.annotation.Nullable Integer accountStatus) {
    this.accountStatus = accountStatus;
  }


  public AccountAttributes accountTitle(@javax.annotation.Nullable String accountTitle) {
    this.accountTitle = accountTitle;
    return this;
  }

  /**
   * A name assigned to the account, typically the account holder name or business entity.
   * @return accountTitle
   */
  @javax.annotation.Nullable
  public String getAccountTitle() {
    return accountTitle;
  }

  public void setAccountTitle(@javax.annotation.Nullable String accountTitle) {
    this.accountTitle = accountTitle;
  }


  public AccountAttributes accountVan(@javax.annotation.Nullable String accountVan) {
    this.accountVan = accountVan;
    return this;
  }

  /**
   * The account&#39;s virtual account number, or otherwise its IB accountId if no VAN is set.
   * @return accountVan
   */
  @javax.annotation.Nullable
  public String getAccountVan() {
    return accountVan;
  }

  public void setAccountVan(@javax.annotation.Nullable String accountVan) {
    this.accountVan = accountVan;
  }


  public AccountAttributes acctCustType(@javax.annotation.Nullable String acctCustType) {
    this.acctCustType = acctCustType;
    return this;
  }

  /**
   * Identifies the type of client with which the account is associated, such as an individual or LLC.
   * @return acctCustType
   */
  @javax.annotation.Nullable
  public String getAcctCustType() {
    return acctCustType;
  }

  public void setAcctCustType(@javax.annotation.Nullable String acctCustType) {
    this.acctCustType = acctCustType;
  }


  public AccountAttributes brokerageAccess(@javax.annotation.Nullable Boolean brokerageAccess) {
    this.brokerageAccess = brokerageAccess;
    return this;
  }

  /**
   * Indicates whether account can receive live orders (do not mix with paper trading).
   * @return brokerageAccess
   */
  @javax.annotation.Nullable
  public Boolean getBrokerageAccess() {
    return brokerageAccess;
  }

  public void setBrokerageAccess(@javax.annotation.Nullable Boolean brokerageAccess) {
    this.brokerageAccess = brokerageAccess;
  }


  public AccountAttributes businessType(@javax.annotation.Nullable BusinessTypeEnum businessType) {
    this.businessType = businessType;
    return this;
  }

  /**
   * A descriptor of the nature of the account, reflecting the responsible group within IB.
   * @return businessType
   */
  @javax.annotation.Nullable
  public BusinessTypeEnum getBusinessType() {
    return businessType;
  }

  public void setBusinessType(@javax.annotation.Nullable BusinessTypeEnum businessType) {
    this.businessType = businessType;
  }


  public AccountAttributes clearingStatus(@javax.annotation.Nullable ClearingStatusEnum clearingStatus) {
    this.clearingStatus = clearingStatus;
    return this;
  }

  /**
   * Status of the account with respect to clearing at IB. O is open, P pending, N new, A abandoned, C closed, R rejected.
   * @return clearingStatus
   */
  @javax.annotation.Nullable
  public ClearingStatusEnum getClearingStatus() {
    return clearingStatus;
  }

  public void setClearingStatus(@javax.annotation.Nullable ClearingStatusEnum clearingStatus) {
    this.clearingStatus = clearingStatus;
  }


  public AccountAttributes covestor(@javax.annotation.Nullable Boolean covestor) {
    this.covestor = covestor;
    return this;
  }

  /**
   * Indicates a Covestor account.
   * @return covestor
   */
  @javax.annotation.Nullable
  public Boolean getCovestor() {
    return covestor;
  }

  public void setCovestor(@javax.annotation.Nullable Boolean covestor) {
    this.covestor = covestor;
  }


  public AccountAttributes currency(@javax.annotation.Nullable CurrencyEnum currency) {
    this.currency = currency;
    return this;
  }

  /**
   * Base currency of the account.
   * @return currency
   */
  @javax.annotation.Nullable
  public CurrencyEnum getCurrency() {
    return currency;
  }

  public void setCurrency(@javax.annotation.Nullable CurrencyEnum currency) {
    this.currency = currency;
  }


  public AccountAttributes desc(@javax.annotation.Nullable String desc) {
    this.desc = desc;
    return this;
  }

  /**
   * Internal human-readable description of the account.
   * @return desc
   */
  @javax.annotation.Nullable
  public String getDesc() {
    return desc;
  }

  public void setDesc(@javax.annotation.Nullable String desc) {
    this.desc = desc;
  }


  public AccountAttributes displayName(@javax.annotation.Nullable String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * Displayed name of the account in UI. Will reflect either the accountId or accountAlias, if set.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(@javax.annotation.Nullable String displayName) {
    this.displayName = displayName;
  }


  public AccountAttributes faClient(@javax.annotation.Nullable Boolean faClient) {
    this.faClient = faClient;
    return this;
  }

  /**
   * Indicates that the account is managed by a financial advisor.
   * @return faClient
   */
  @javax.annotation.Nullable
  public Boolean getFaClient() {
    return faClient;
  }

  public void setFaClient(@javax.annotation.Nullable Boolean faClient) {
    this.faClient = faClient;
  }


  public AccountAttributes ibEntity(@javax.annotation.Nullable IbEntityEnum ibEntity) {
    this.ibEntity = ibEntity;
    return this;
  }

  /**
   * IB business entity under which the account resides.
   * @return ibEntity
   */
  @javax.annotation.Nullable
  public IbEntityEnum getIbEntity() {
    return ibEntity;
  }

  public void setIbEntity(@javax.annotation.Nullable IbEntityEnum ibEntity) {
    this.ibEntity = ibEntity;
  }


  public AccountAttributes id(@javax.annotation.Nullable String id) {
    this.id = id;
    return this;
  }

  /**
   * The account&#39;s IB accountId.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nullable String id) {
    this.id = id;
  }


  public AccountAttributes noClientTrading(@javax.annotation.Nullable Boolean noClientTrading) {
    this.noClientTrading = noClientTrading;
    return this;
  }

  /**
   * Indicates that trading by the client is disabled in the account.
   * @return noClientTrading
   */
  @javax.annotation.Nullable
  public Boolean getNoClientTrading() {
    return noClientTrading;
  }

  public void setNoClientTrading(@javax.annotation.Nullable Boolean noClientTrading) {
    this.noClientTrading = noClientTrading;
  }


  public AccountAttributes parent(@javax.annotation.Nullable AccountAttributesParent parent) {
    this.parent = parent;
    return this;
  }

  /**
   * Get parent
   * @return parent
   */
  @javax.annotation.Nullable
  public AccountAttributesParent getParent() {
    return parent;
  }

  public void setParent(@javax.annotation.Nullable AccountAttributesParent parent) {
    this.parent = parent;
  }


  public AccountAttributes prepaidCryptoP(@javax.annotation.Nullable Boolean prepaidCryptoP) {
    this.prepaidCryptoP = prepaidCryptoP;
    return this;
  }

  /**
   * Indicates whether account has a prepaid crypto segment (Crypto Plus) with PAXOS.
   * @return prepaidCryptoP
   */
  @javax.annotation.Nullable
  public Boolean getPrepaidCryptoP() {
    return prepaidCryptoP;
  }

  public void setPrepaidCryptoP(@javax.annotation.Nullable Boolean prepaidCryptoP) {
    this.prepaidCryptoP = prepaidCryptoP;
  }


  public AccountAttributes prepaidCryptoZ(@javax.annotation.Nullable Boolean prepaidCryptoZ) {
    this.prepaidCryptoZ = prepaidCryptoZ;
    return this;
  }

  /**
   * Indicates whether account has a prepaid crypto segment (Crypto Plus) with ZEROHASH.
   * @return prepaidCryptoZ
   */
  @javax.annotation.Nullable
  public Boolean getPrepaidCryptoZ() {
    return prepaidCryptoZ;
  }

  public void setPrepaidCryptoZ(@javax.annotation.Nullable Boolean prepaidCryptoZ) {
    this.prepaidCryptoZ = prepaidCryptoZ;
  }


  public AccountAttributes trackVirtualFXPortfolio(@javax.annotation.Nullable Boolean trackVirtualFXPortfolio) {
    this.trackVirtualFXPortfolio = trackVirtualFXPortfolio;
    return this;
  }

  /**
   * Indicates that virtual forex positions are tracked in the account.
   * @return trackVirtualFXPortfolio
   */
  @javax.annotation.Nullable
  public Boolean getTrackVirtualFXPortfolio() {
    return trackVirtualFXPortfolio;
  }

  public void setTrackVirtualFXPortfolio(@javax.annotation.Nullable Boolean trackVirtualFXPortfolio) {
    this.trackVirtualFXPortfolio = trackVirtualFXPortfolio;
  }


  public AccountAttributes tradingType(@javax.annotation.Nullable TradingTypeEnum tradingType) {
    this.tradingType = tradingType;
    return this;
  }

  /**
   * Internal identifier used by IB to reflect the trading permissions of the account.
   * @return tradingType
   */
  @javax.annotation.Nullable
  public TradingTypeEnum getTradingType() {
    return tradingType;
  }

  public void setTradingType(@javax.annotation.Nullable TradingTypeEnum tradingType) {
    this.tradingType = tradingType;
  }


  public AccountAttributes type(@javax.annotation.Nullable TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * Indicates whether the account exists in production, paper, or demo environments.
   * @return type
   */
  @javax.annotation.Nullable
  public TypeEnum getType() {
    return type;
  }

  public void setType(@javax.annotation.Nullable TypeEnum type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AccountAttributes accountAttributes = (AccountAttributes) o;
    return Objects.equals(this.accountAlias, accountAttributes.accountAlias) &&
        Objects.equals(this.accountStatus, accountAttributes.accountStatus) &&
        Objects.equals(this.accountTitle, accountAttributes.accountTitle) &&
        Objects.equals(this.accountVan, accountAttributes.accountVan) &&
        Objects.equals(this.acctCustType, accountAttributes.acctCustType) &&
        Objects.equals(this.brokerageAccess, accountAttributes.brokerageAccess) &&
        Objects.equals(this.businessType, accountAttributes.businessType) &&
        Objects.equals(this.clearingStatus, accountAttributes.clearingStatus) &&
        Objects.equals(this.covestor, accountAttributes.covestor) &&
        Objects.equals(this.currency, accountAttributes.currency) &&
        Objects.equals(this.desc, accountAttributes.desc) &&
        Objects.equals(this.displayName, accountAttributes.displayName) &&
        Objects.equals(this.faClient, accountAttributes.faClient) &&
        Objects.equals(this.ibEntity, accountAttributes.ibEntity) &&
        Objects.equals(this.id, accountAttributes.id) &&
        Objects.equals(this.noClientTrading, accountAttributes.noClientTrading) &&
        Objects.equals(this.parent, accountAttributes.parent) &&
        Objects.equals(this.prepaidCryptoP, accountAttributes.prepaidCryptoP) &&
        Objects.equals(this.prepaidCryptoZ, accountAttributes.prepaidCryptoZ) &&
        Objects.equals(this.trackVirtualFXPortfolio, accountAttributes.trackVirtualFXPortfolio) &&
        Objects.equals(this.tradingType, accountAttributes.tradingType) &&
        Objects.equals(this.type, accountAttributes.type);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountAlias, accountStatus, accountTitle, accountVan, acctCustType, brokerageAccess, businessType, clearingStatus, covestor, currency, desc, displayName, faClient, ibEntity, id, noClientTrading, parent, prepaidCryptoP, prepaidCryptoZ, trackVirtualFXPortfolio, tradingType, type);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AccountAttributes {\n");
    sb.append("    accountAlias: ").append(toIndentedString(accountAlias)).append("\n");
    sb.append("    accountStatus: ").append(toIndentedString(accountStatus)).append("\n");
    sb.append("    accountTitle: ").append(toIndentedString(accountTitle)).append("\n");
    sb.append("    accountVan: ").append(toIndentedString(accountVan)).append("\n");
    sb.append("    acctCustType: ").append(toIndentedString(acctCustType)).append("\n");
    sb.append("    brokerageAccess: ").append(toIndentedString(brokerageAccess)).append("\n");
    sb.append("    businessType: ").append(toIndentedString(businessType)).append("\n");
    sb.append("    clearingStatus: ").append(toIndentedString(clearingStatus)).append("\n");
    sb.append("    covestor: ").append(toIndentedString(covestor)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    desc: ").append(toIndentedString(desc)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    faClient: ").append(toIndentedString(faClient)).append("\n");
    sb.append("    ibEntity: ").append(toIndentedString(ibEntity)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    noClientTrading: ").append(toIndentedString(noClientTrading)).append("\n");
    sb.append("    parent: ").append(toIndentedString(parent)).append("\n");
    sb.append("    prepaidCryptoP: ").append(toIndentedString(prepaidCryptoP)).append("\n");
    sb.append("    prepaidCryptoZ: ").append(toIndentedString(prepaidCryptoZ)).append("\n");
    sb.append("    trackVirtualFXPortfolio: ").append(toIndentedString(trackVirtualFXPortfolio)).append("\n");
    sb.append("    tradingType: ").append(toIndentedString(tradingType)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accountAlias");
    openapiFields.add("accountStatus");
    openapiFields.add("accountTitle");
    openapiFields.add("accountVan");
    openapiFields.add("acctCustType");
    openapiFields.add("brokerageAccess");
    openapiFields.add("businessType");
    openapiFields.add("clearingStatus");
    openapiFields.add("covestor");
    openapiFields.add("currency");
    openapiFields.add("desc");
    openapiFields.add("displayName");
    openapiFields.add("faClient");
    openapiFields.add("ibEntity");
    openapiFields.add("id");
    openapiFields.add("noClientTrading");
    openapiFields.add("parent");
    openapiFields.add("PrepaidCrypto-P");
    openapiFields.add("PrepaidCrypto-Z");
    openapiFields.add("trackVirtualFXPortfolio");
    openapiFields.add("tradingType");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AccountAttributes
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AccountAttributes.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AccountAttributes is not found in the empty JSON string", AccountAttributes.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AccountAttributes.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AccountAttributes` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("accountAlias") != null && !jsonObj.get("accountAlias").isJsonNull()) && !jsonObj.get("accountAlias").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accountAlias` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accountAlias").toString()));
      }
      if ((jsonObj.get("accountTitle") != null && !jsonObj.get("accountTitle").isJsonNull()) && !jsonObj.get("accountTitle").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accountTitle` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accountTitle").toString()));
      }
      if ((jsonObj.get("accountVan") != null && !jsonObj.get("accountVan").isJsonNull()) && !jsonObj.get("accountVan").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accountVan` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accountVan").toString()));
      }
      if ((jsonObj.get("acctCustType") != null && !jsonObj.get("acctCustType").isJsonNull()) && !jsonObj.get("acctCustType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `acctCustType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("acctCustType").toString()));
      }
      if ((jsonObj.get("businessType") != null && !jsonObj.get("businessType").isJsonNull()) && !jsonObj.get("businessType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `businessType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("businessType").toString()));
      }
      // validate the optional field `businessType`
      if (jsonObj.get("businessType") != null && !jsonObj.get("businessType").isJsonNull()) {
        BusinessTypeEnum.validateJsonElement(jsonObj.get("businessType"));
      }
      if ((jsonObj.get("clearingStatus") != null && !jsonObj.get("clearingStatus").isJsonNull()) && !jsonObj.get("clearingStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clearingStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clearingStatus").toString()));
      }
      // validate the optional field `clearingStatus`
      if (jsonObj.get("clearingStatus") != null && !jsonObj.get("clearingStatus").isJsonNull()) {
        ClearingStatusEnum.validateJsonElement(jsonObj.get("clearingStatus"));
      }
      if ((jsonObj.get("currency") != null && !jsonObj.get("currency").isJsonNull()) && !jsonObj.get("currency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currency").toString()));
      }
      // validate the optional field `currency`
      if (jsonObj.get("currency") != null && !jsonObj.get("currency").isJsonNull()) {
        CurrencyEnum.validateJsonElement(jsonObj.get("currency"));
      }
      if ((jsonObj.get("desc") != null && !jsonObj.get("desc").isJsonNull()) && !jsonObj.get("desc").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `desc` to be a primitive type in the JSON string but got `%s`", jsonObj.get("desc").toString()));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("ibEntity") != null && !jsonObj.get("ibEntity").isJsonNull()) && !jsonObj.get("ibEntity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ibEntity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ibEntity").toString()));
      }
      // validate the optional field `ibEntity`
      if (jsonObj.get("ibEntity") != null && !jsonObj.get("ibEntity").isJsonNull()) {
        IbEntityEnum.validateJsonElement(jsonObj.get("ibEntity"));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `parent`
      if (jsonObj.get("parent") != null && !jsonObj.get("parent").isJsonNull()) {
        AccountAttributesParent.validateJsonElement(jsonObj.get("parent"));
      }
      if ((jsonObj.get("tradingType") != null && !jsonObj.get("tradingType").isJsonNull()) && !jsonObj.get("tradingType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tradingType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tradingType").toString()));
      }
      // validate the optional field `tradingType`
      if (jsonObj.get("tradingType") != null && !jsonObj.get("tradingType").isJsonNull()) {
        TradingTypeEnum.validateJsonElement(jsonObj.get("tradingType"));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        TypeEnum.validateJsonElement(jsonObj.get("type"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AccountAttributes.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AccountAttributes' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AccountAttributes> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AccountAttributes.class));

       return (TypeAdapter<T>) new TypeAdapter<AccountAttributes>() {
           @Override
           public void write(JsonWriter out, AccountAttributes value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AccountAttributes read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AccountAttributes given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AccountAttributes
   * @throws IOException if the JSON string is invalid with respect to AccountAttributes
   */
  public static AccountAttributes fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AccountAttributes.class);
  }

  /**
   * Convert an instance of AccountAttributes to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

