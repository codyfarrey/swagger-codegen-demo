/*
 * IB REST API
 * The IB REST API reference documentation
 *
 * The version of the OpenAPI document: 2.13.0
 * Contact: api@interactivebrokers.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.SingleHistoricalBar;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Object containing the requested historical data and related metadata.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-03-18T20:44:00.611784800-05:00[America/Chicago]", comments = "Generator version: 7.12.0")
public class IserverHistoryResponse {
  public static final String SERIALIZED_NAME_SERVER_ID = "serverId";
  @SerializedName(SERIALIZED_NAME_SERVER_ID)
  @javax.annotation.Nullable
  private String serverId;

  public static final String SERIALIZED_NAME_SYMBOL = "symbol";
  @SerializedName(SERIALIZED_NAME_SYMBOL)
  @javax.annotation.Nullable
  private String symbol;

  public static final String SERIALIZED_NAME_TEXT = "text";
  @SerializedName(SERIALIZED_NAME_TEXT)
  @javax.annotation.Nullable
  private String text;

  public static final String SERIALIZED_NAME_PRICE_FACTOR = "priceFactor";
  @SerializedName(SERIALIZED_NAME_PRICE_FACTOR)
  @javax.annotation.Nullable
  private Integer priceFactor;

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  @javax.annotation.Nullable
  private String startTime;

  public static final String SERIALIZED_NAME_HIGH = "high";
  @SerializedName(SERIALIZED_NAME_HIGH)
  @javax.annotation.Nullable
  private String high;

  public static final String SERIALIZED_NAME_LOW = "low";
  @SerializedName(SERIALIZED_NAME_LOW)
  @javax.annotation.Nullable
  private String low;

  public static final String SERIALIZED_NAME_TIME_PERIOD = "timePeriod";
  @SerializedName(SERIALIZED_NAME_TIME_PERIOD)
  @javax.annotation.Nullable
  private String timePeriod;

  public static final String SERIALIZED_NAME_BAR_LENGTH = "barLength";
  @SerializedName(SERIALIZED_NAME_BAR_LENGTH)
  @javax.annotation.Nullable
  private Integer barLength;

  public static final String SERIALIZED_NAME_MD_AVAILABILITY = "mdAvailability";
  @SerializedName(SERIALIZED_NAME_MD_AVAILABILITY)
  @javax.annotation.Nullable
  private String mdAvailability;

  public static final String SERIALIZED_NAME_OUTSIDE_RTH = "outsideRth";
  @SerializedName(SERIALIZED_NAME_OUTSIDE_RTH)
  @javax.annotation.Nullable
  private Boolean outsideRth;

  public static final String SERIALIZED_NAME_TRADING_DAY_DURATION = "tradingDayDuration";
  @SerializedName(SERIALIZED_NAME_TRADING_DAY_DURATION)
  @javax.annotation.Nullable
  private Integer tradingDayDuration;

  public static final String SERIALIZED_NAME_VOLUME_FACTOR = "volumeFactor";
  @SerializedName(SERIALIZED_NAME_VOLUME_FACTOR)
  @javax.annotation.Nullable
  private Integer volumeFactor;

  public static final String SERIALIZED_NAME_PRICE_DISPLAY_RULE = "priceDisplayRule";
  @SerializedName(SERIALIZED_NAME_PRICE_DISPLAY_RULE)
  @javax.annotation.Nullable
  private Integer priceDisplayRule;

  public static final String SERIALIZED_NAME_PRICE_DISPLAY_VALUE = "priceDisplayValue";
  @SerializedName(SERIALIZED_NAME_PRICE_DISPLAY_VALUE)
  @javax.annotation.Nullable
  private String priceDisplayValue;

  public static final String SERIALIZED_NAME_CHART_PAN_START_TIME = "chartPanStartTime";
  @SerializedName(SERIALIZED_NAME_CHART_PAN_START_TIME)
  @javax.annotation.Nullable
  private String chartPanStartTime;

  public static final String SERIALIZED_NAME_DIRECTION = "direction";
  @SerializedName(SERIALIZED_NAME_DIRECTION)
  @javax.annotation.Nullable
  private Integer direction;

  public static final String SERIALIZED_NAME_NEGATIVE_CAPABLE = "negativeCapable";
  @SerializedName(SERIALIZED_NAME_NEGATIVE_CAPABLE)
  @javax.annotation.Nullable
  private Boolean negativeCapable;

  public static final String SERIALIZED_NAME_MESSAGE_VERSION = "messageVersion";
  @SerializedName(SERIALIZED_NAME_MESSAGE_VERSION)
  @javax.annotation.Nullable
  private Integer messageVersion;

  public static final String SERIALIZED_NAME_TRAVEL_TIME = "travelTime";
  @SerializedName(SERIALIZED_NAME_TRAVEL_TIME)
  @javax.annotation.Nullable
  private Integer travelTime;

  public static final String SERIALIZED_NAME_DATA = "data";
  @SerializedName(SERIALIZED_NAME_DATA)
  @javax.annotation.Nullable
  private List<SingleHistoricalBar> data = new ArrayList<>();

  public static final String SERIALIZED_NAME_POINTS = "points";
  @SerializedName(SERIALIZED_NAME_POINTS)
  @javax.annotation.Nullable
  private Integer points;

  public static final String SERIALIZED_NAME_MKT_DATA_DELAY = "mktDataDelay";
  @SerializedName(SERIALIZED_NAME_MKT_DATA_DELAY)
  @javax.annotation.Nullable
  private Integer mktDataDelay;

  public IserverHistoryResponse() {
  }

  public IserverHistoryResponse serverId(@javax.annotation.Nullable String serverId) {
    this.serverId = serverId;
    return this;
  }

  /**
   * Internal use. Identifier of the request.
   * @return serverId
   */
  @javax.annotation.Nullable
  public String getServerId() {
    return serverId;
  }

  public void setServerId(@javax.annotation.Nullable String serverId) {
    this.serverId = serverId;
  }


  public IserverHistoryResponse symbol(@javax.annotation.Nullable String symbol) {
    this.symbol = symbol;
    return this;
  }

  /**
   * Symbol of the request instrument.
   * @return symbol
   */
  @javax.annotation.Nullable
  public String getSymbol() {
    return symbol;
  }

  public void setSymbol(@javax.annotation.Nullable String symbol) {
    this.symbol = symbol;
  }


  public IserverHistoryResponse text(@javax.annotation.Nullable String text) {
    this.text = text;
    return this;
  }

  /**
   * Description or company name of the instrument.
   * @return text
   */
  @javax.annotation.Nullable
  public String getText() {
    return text;
  }

  public void setText(@javax.annotation.Nullable String text) {
    this.text = text;
  }


  public IserverHistoryResponse priceFactor(@javax.annotation.Nullable Integer priceFactor) {
    this.priceFactor = priceFactor;
    return this;
  }

  /**
   * Internal use. Used to scale Client Portal chart Y-axis.
   * @return priceFactor
   */
  @javax.annotation.Nullable
  public Integer getPriceFactor() {
    return priceFactor;
  }

  public void setPriceFactor(@javax.annotation.Nullable Integer priceFactor) {
    this.priceFactor = priceFactor;
  }


  public IserverHistoryResponse startTime(@javax.annotation.Nullable String startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * UTC date and time of the start (chronologically earlier) of the complete period in format YYYYMMDD-hh:mm:ss.
   * @return startTime
   */
  @javax.annotation.Nullable
  public String getStartTime() {
    return startTime;
  }

  public void setStartTime(@javax.annotation.Nullable String startTime) {
    this.startTime = startTime;
  }


  public IserverHistoryResponse high(@javax.annotation.Nullable String high) {
    this.high = high;
    return this;
  }

  /**
   * Internal use. Delivers highest price value in total interval. Used for chart scaling. A string constructed as &#39;highestPrice*priceFactor/totalVolume*volumeFactor/minutesFromStartTime&#39;.
   * @return high
   */
  @javax.annotation.Nullable
  public String getHigh() {
    return high;
  }

  public void setHigh(@javax.annotation.Nullable String high) {
    this.high = high;
  }


  public IserverHistoryResponse low(@javax.annotation.Nullable String low) {
    this.low = low;
    return this;
  }

  /**
   * Internal use. Delivers lowest price value in total interval. Used for chart scaling. A string constructed as &#39;lowestPrice*priceFactor/totalVolume*volumeFactor/minutesFromStartTime&#39;.
   * @return low
   */
  @javax.annotation.Nullable
  public String getLow() {
    return low;
  }

  public void setLow(@javax.annotation.Nullable String low) {
    this.low = low;
  }


  public IserverHistoryResponse timePeriod(@javax.annotation.Nullable String timePeriod) {
    this.timePeriod = timePeriod;
    return this;
  }

  /**
   * The client-specified period value.
   * @return timePeriod
   */
  @javax.annotation.Nullable
  public String getTimePeriod() {
    return timePeriod;
  }

  public void setTimePeriod(@javax.annotation.Nullable String timePeriod) {
    this.timePeriod = timePeriod;
  }


  public IserverHistoryResponse barLength(@javax.annotation.Nullable Integer barLength) {
    this.barLength = barLength;
    return this;
  }

  /**
   * The client-specified bar width, represented in seconds.
   * @return barLength
   */
  @javax.annotation.Nullable
  public Integer getBarLength() {
    return barLength;
  }

  public void setBarLength(@javax.annotation.Nullable Integer barLength) {
    this.barLength = barLength;
  }


  public IserverHistoryResponse mdAvailability(@javax.annotation.Nullable String mdAvailability) {
    this.mdAvailability = mdAvailability;
    return this;
  }

  /**
   * A three-character string reflecting the nature of available data. R &#x3D; Realtime, D &#x3D; Delayed, Z &#x3D; Frozen, Y &#x3D; Frozen Delayed, N &#x3D; Not Subscribed. P &#x3D; Snapshot, p &#x3D; Consolidated. B &#x3D; Top of book.
   * @return mdAvailability
   */
  @javax.annotation.Nullable
  public String getMdAvailability() {
    return mdAvailability;
  }

  public void setMdAvailability(@javax.annotation.Nullable String mdAvailability) {
    this.mdAvailability = mdAvailability;
  }


  public IserverHistoryResponse outsideRth(@javax.annotation.Nullable Boolean outsideRth) {
    this.outsideRth = outsideRth;
    return this;
  }

  /**
   * Indicates whether data from outside regular trading hours is included in the response.
   * @return outsideRth
   */
  @javax.annotation.Nullable
  public Boolean getOutsideRth() {
    return outsideRth;
  }

  public void setOutsideRth(@javax.annotation.Nullable Boolean outsideRth) {
    this.outsideRth = outsideRth;
  }


  public IserverHistoryResponse tradingDayDuration(@javax.annotation.Nullable Integer tradingDayDuration) {
    this.tradingDayDuration = tradingDayDuration;
    return this;
  }

  /**
   * Length of instrument&#39;s trading day in seconds.
   * @return tradingDayDuration
   */
  @javax.annotation.Nullable
  public Integer getTradingDayDuration() {
    return tradingDayDuration;
  }

  public void setTradingDayDuration(@javax.annotation.Nullable Integer tradingDayDuration) {
    this.tradingDayDuration = tradingDayDuration;
  }


  public IserverHistoryResponse volumeFactor(@javax.annotation.Nullable Integer volumeFactor) {
    this.volumeFactor = volumeFactor;
    return this;
  }

  /**
   * Internal use. Used to scale volume histograms.
   * @return volumeFactor
   */
  @javax.annotation.Nullable
  public Integer getVolumeFactor() {
    return volumeFactor;
  }

  public void setVolumeFactor(@javax.annotation.Nullable Integer volumeFactor) {
    this.volumeFactor = volumeFactor;
  }


  public IserverHistoryResponse priceDisplayRule(@javax.annotation.Nullable Integer priceDisplayRule) {
    this.priceDisplayRule = priceDisplayRule;
    return this;
  }

  /**
   * Internal use. Governs application of pricing display rule.
   * @return priceDisplayRule
   */
  @javax.annotation.Nullable
  public Integer getPriceDisplayRule() {
    return priceDisplayRule;
  }

  public void setPriceDisplayRule(@javax.annotation.Nullable Integer priceDisplayRule) {
    this.priceDisplayRule = priceDisplayRule;
  }


  public IserverHistoryResponse priceDisplayValue(@javax.annotation.Nullable String priceDisplayValue) {
    this.priceDisplayValue = priceDisplayValue;
    return this;
  }

  /**
   * Internal use. Governs rendering of displayed pricing.
   * @return priceDisplayValue
   */
  @javax.annotation.Nullable
  public String getPriceDisplayValue() {
    return priceDisplayValue;
  }

  public void setPriceDisplayValue(@javax.annotation.Nullable String priceDisplayValue) {
    this.priceDisplayValue = priceDisplayValue;
  }


  public IserverHistoryResponse chartPanStartTime(@javax.annotation.Nullable String chartPanStartTime) {
    this.chartPanStartTime = chartPanStartTime;
    return this;
  }

  /**
   * Internal use. UTC datetime string used to center Client Portal charts. Format YYYYMMDD-hh:mm:ss.
   * @return chartPanStartTime
   */
  @javax.annotation.Nullable
  public String getChartPanStartTime() {
    return chartPanStartTime;
  }

  public void setChartPanStartTime(@javax.annotation.Nullable String chartPanStartTime) {
    this.chartPanStartTime = chartPanStartTime;
  }


  public IserverHistoryResponse direction(@javax.annotation.Nullable Integer direction) {
    this.direction = direction;
    return this;
  }

  /**
   * Indicates how the period is applied in relation to the startTime. Value will always be -1, indicating that the period extends from the startTime forward into the future.
   * @return direction
   */
  @javax.annotation.Nullable
  public Integer getDirection() {
    return direction;
  }

  public void setDirection(@javax.annotation.Nullable Integer direction) {
    this.direction = direction;
  }


  public IserverHistoryResponse negativeCapable(@javax.annotation.Nullable Boolean negativeCapable) {
    this.negativeCapable = negativeCapable;
    return this;
  }

  /**
   * Indicates whether instrument is capable of negative pricing.
   * @return negativeCapable
   */
  @javax.annotation.Nullable
  public Boolean getNegativeCapable() {
    return negativeCapable;
  }

  public void setNegativeCapable(@javax.annotation.Nullable Boolean negativeCapable) {
    this.negativeCapable = negativeCapable;
  }


  public IserverHistoryResponse messageVersion(@javax.annotation.Nullable Integer messageVersion) {
    this.messageVersion = messageVersion;
    return this;
  }

  /**
   * Internal use. Reflects the version of the response schema used.
   * @return messageVersion
   */
  @javax.annotation.Nullable
  public Integer getMessageVersion() {
    return messageVersion;
  }

  public void setMessageVersion(@javax.annotation.Nullable Integer messageVersion) {
    this.messageVersion = messageVersion;
  }


  public IserverHistoryResponse travelTime(@javax.annotation.Nullable Integer travelTime) {
    this.travelTime = travelTime;
    return this;
  }

  /**
   * Internal time in flight to serve the request.
   * @return travelTime
   */
  @javax.annotation.Nullable
  public Integer getTravelTime() {
    return travelTime;
  }

  public void setTravelTime(@javax.annotation.Nullable Integer travelTime) {
    this.travelTime = travelTime;
  }


  public IserverHistoryResponse data(@javax.annotation.Nullable List<SingleHistoricalBar> data) {
    this.data = data;
    return this;
  }

  public IserverHistoryResponse addDataItem(SingleHistoricalBar dataItem) {
    if (this.data == null) {
      this.data = new ArrayList<>();
    }
    this.data.add(dataItem);
    return this;
  }

  /**
   * Array containing OHLC bars for the requested period.
   * @return data
   */
  @javax.annotation.Nullable
  public List<SingleHistoricalBar> getData() {
    return data;
  }

  public void setData(@javax.annotation.Nullable List<SingleHistoricalBar> data) {
    this.data = data;
  }


  public IserverHistoryResponse points(@javax.annotation.Nullable Integer points) {
    this.points = points;
    return this;
  }

  /**
   * Count of the number of bars returned in the data array.
   * @return points
   */
  @javax.annotation.Nullable
  public Integer getPoints() {
    return points;
  }

  public void setPoints(@javax.annotation.Nullable Integer points) {
    this.points = points;
  }


  public IserverHistoryResponse mktDataDelay(@javax.annotation.Nullable Integer mktDataDelay) {
    this.mktDataDelay = mktDataDelay;
    return this;
  }

  /**
   * Number of milliseconds taken to satisfy this historical data request.
   * @return mktDataDelay
   */
  @javax.annotation.Nullable
  public Integer getMktDataDelay() {
    return mktDataDelay;
  }

  public void setMktDataDelay(@javax.annotation.Nullable Integer mktDataDelay) {
    this.mktDataDelay = mktDataDelay;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IserverHistoryResponse iserverHistoryResponse = (IserverHistoryResponse) o;
    return Objects.equals(this.serverId, iserverHistoryResponse.serverId) &&
        Objects.equals(this.symbol, iserverHistoryResponse.symbol) &&
        Objects.equals(this.text, iserverHistoryResponse.text) &&
        Objects.equals(this.priceFactor, iserverHistoryResponse.priceFactor) &&
        Objects.equals(this.startTime, iserverHistoryResponse.startTime) &&
        Objects.equals(this.high, iserverHistoryResponse.high) &&
        Objects.equals(this.low, iserverHistoryResponse.low) &&
        Objects.equals(this.timePeriod, iserverHistoryResponse.timePeriod) &&
        Objects.equals(this.barLength, iserverHistoryResponse.barLength) &&
        Objects.equals(this.mdAvailability, iserverHistoryResponse.mdAvailability) &&
        Objects.equals(this.outsideRth, iserverHistoryResponse.outsideRth) &&
        Objects.equals(this.tradingDayDuration, iserverHistoryResponse.tradingDayDuration) &&
        Objects.equals(this.volumeFactor, iserverHistoryResponse.volumeFactor) &&
        Objects.equals(this.priceDisplayRule, iserverHistoryResponse.priceDisplayRule) &&
        Objects.equals(this.priceDisplayValue, iserverHistoryResponse.priceDisplayValue) &&
        Objects.equals(this.chartPanStartTime, iserverHistoryResponse.chartPanStartTime) &&
        Objects.equals(this.direction, iserverHistoryResponse.direction) &&
        Objects.equals(this.negativeCapable, iserverHistoryResponse.negativeCapable) &&
        Objects.equals(this.messageVersion, iserverHistoryResponse.messageVersion) &&
        Objects.equals(this.travelTime, iserverHistoryResponse.travelTime) &&
        Objects.equals(this.data, iserverHistoryResponse.data) &&
        Objects.equals(this.points, iserverHistoryResponse.points) &&
        Objects.equals(this.mktDataDelay, iserverHistoryResponse.mktDataDelay);
  }

  @Override
  public int hashCode() {
    return Objects.hash(serverId, symbol, text, priceFactor, startTime, high, low, timePeriod, barLength, mdAvailability, outsideRth, tradingDayDuration, volumeFactor, priceDisplayRule, priceDisplayValue, chartPanStartTime, direction, negativeCapable, messageVersion, travelTime, data, points, mktDataDelay);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IserverHistoryResponse {\n");
    sb.append("    serverId: ").append(toIndentedString(serverId)).append("\n");
    sb.append("    symbol: ").append(toIndentedString(symbol)).append("\n");
    sb.append("    text: ").append(toIndentedString(text)).append("\n");
    sb.append("    priceFactor: ").append(toIndentedString(priceFactor)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    high: ").append(toIndentedString(high)).append("\n");
    sb.append("    low: ").append(toIndentedString(low)).append("\n");
    sb.append("    timePeriod: ").append(toIndentedString(timePeriod)).append("\n");
    sb.append("    barLength: ").append(toIndentedString(barLength)).append("\n");
    sb.append("    mdAvailability: ").append(toIndentedString(mdAvailability)).append("\n");
    sb.append("    outsideRth: ").append(toIndentedString(outsideRth)).append("\n");
    sb.append("    tradingDayDuration: ").append(toIndentedString(tradingDayDuration)).append("\n");
    sb.append("    volumeFactor: ").append(toIndentedString(volumeFactor)).append("\n");
    sb.append("    priceDisplayRule: ").append(toIndentedString(priceDisplayRule)).append("\n");
    sb.append("    priceDisplayValue: ").append(toIndentedString(priceDisplayValue)).append("\n");
    sb.append("    chartPanStartTime: ").append(toIndentedString(chartPanStartTime)).append("\n");
    sb.append("    direction: ").append(toIndentedString(direction)).append("\n");
    sb.append("    negativeCapable: ").append(toIndentedString(negativeCapable)).append("\n");
    sb.append("    messageVersion: ").append(toIndentedString(messageVersion)).append("\n");
    sb.append("    travelTime: ").append(toIndentedString(travelTime)).append("\n");
    sb.append("    data: ").append(toIndentedString(data)).append("\n");
    sb.append("    points: ").append(toIndentedString(points)).append("\n");
    sb.append("    mktDataDelay: ").append(toIndentedString(mktDataDelay)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("serverId");
    openapiFields.add("symbol");
    openapiFields.add("text");
    openapiFields.add("priceFactor");
    openapiFields.add("startTime");
    openapiFields.add("high");
    openapiFields.add("low");
    openapiFields.add("timePeriod");
    openapiFields.add("barLength");
    openapiFields.add("mdAvailability");
    openapiFields.add("outsideRth");
    openapiFields.add("tradingDayDuration");
    openapiFields.add("volumeFactor");
    openapiFields.add("priceDisplayRule");
    openapiFields.add("priceDisplayValue");
    openapiFields.add("chartPanStartTime");
    openapiFields.add("direction");
    openapiFields.add("negativeCapable");
    openapiFields.add("messageVersion");
    openapiFields.add("travelTime");
    openapiFields.add("data");
    openapiFields.add("points");
    openapiFields.add("mktDataDelay");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to IserverHistoryResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!IserverHistoryResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in IserverHistoryResponse is not found in the empty JSON string", IserverHistoryResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!IserverHistoryResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `IserverHistoryResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("serverId") != null && !jsonObj.get("serverId").isJsonNull()) && !jsonObj.get("serverId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serverId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serverId").toString()));
      }
      if ((jsonObj.get("symbol") != null && !jsonObj.get("symbol").isJsonNull()) && !jsonObj.get("symbol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `symbol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("symbol").toString()));
      }
      if ((jsonObj.get("text") != null && !jsonObj.get("text").isJsonNull()) && !jsonObj.get("text").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `text` to be a primitive type in the JSON string but got `%s`", jsonObj.get("text").toString()));
      }
      if ((jsonObj.get("startTime") != null && !jsonObj.get("startTime").isJsonNull()) && !jsonObj.get("startTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `startTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("startTime").toString()));
      }
      if ((jsonObj.get("high") != null && !jsonObj.get("high").isJsonNull()) && !jsonObj.get("high").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `high` to be a primitive type in the JSON string but got `%s`", jsonObj.get("high").toString()));
      }
      if ((jsonObj.get("low") != null && !jsonObj.get("low").isJsonNull()) && !jsonObj.get("low").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `low` to be a primitive type in the JSON string but got `%s`", jsonObj.get("low").toString()));
      }
      if ((jsonObj.get("timePeriod") != null && !jsonObj.get("timePeriod").isJsonNull()) && !jsonObj.get("timePeriod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timePeriod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timePeriod").toString()));
      }
      if ((jsonObj.get("mdAvailability") != null && !jsonObj.get("mdAvailability").isJsonNull()) && !jsonObj.get("mdAvailability").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mdAvailability` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mdAvailability").toString()));
      }
      if ((jsonObj.get("priceDisplayValue") != null && !jsonObj.get("priceDisplayValue").isJsonNull()) && !jsonObj.get("priceDisplayValue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `priceDisplayValue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("priceDisplayValue").toString()));
      }
      if ((jsonObj.get("chartPanStartTime") != null && !jsonObj.get("chartPanStartTime").isJsonNull()) && !jsonObj.get("chartPanStartTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `chartPanStartTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("chartPanStartTime").toString()));
      }
      if (jsonObj.get("data") != null && !jsonObj.get("data").isJsonNull()) {
        JsonArray jsonArraydata = jsonObj.getAsJsonArray("data");
        if (jsonArraydata != null) {
          // ensure the json data is an array
          if (!jsonObj.get("data").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `data` to be an array in the JSON string but got `%s`", jsonObj.get("data").toString()));
          }

          // validate the optional field `data` (array)
          for (int i = 0; i < jsonArraydata.size(); i++) {
            SingleHistoricalBar.validateJsonElement(jsonArraydata.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!IserverHistoryResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'IserverHistoryResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<IserverHistoryResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(IserverHistoryResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<IserverHistoryResponse>() {
           @Override
           public void write(JsonWriter out, IserverHistoryResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public IserverHistoryResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of IserverHistoryResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of IserverHistoryResponse
   * @throws IOException if the JSON string is invalid with respect to IserverHistoryResponse
   */
  public static IserverHistoryResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, IserverHistoryResponse.class);
  }

  /**
   * Convert an instance of IserverHistoryResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

