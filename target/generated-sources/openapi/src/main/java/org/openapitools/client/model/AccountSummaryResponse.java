/*
 * IB REST API
 * The IB REST API reference documentation
 *
 * The version of the OpenAPI document: 2.13.0
 * Contact: api@interactivebrokers.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AccountSummaryResponseCashBalancesInner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Successful return contianing an array of at-a-glance account details.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-03-18T20:44:00.611784800-05:00[America/Chicago]", comments = "Generator version: 7.12.0")
public class AccountSummaryResponse {
  public static final String SERIALIZED_NAME_ACCOUNT_TYPE = "accountType";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_TYPE)
  @javax.annotation.Nullable
  private String accountType;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  @javax.annotation.Nullable
  private String status;

  public static final String SERIALIZED_NAME_BALANCE = "balance";
  @SerializedName(SERIALIZED_NAME_BALANCE)
  @javax.annotation.Nullable
  private Integer balance;

  public static final String SERIALIZED_NAME_S_M_A = "SMA";
  @SerializedName(SERIALIZED_NAME_S_M_A)
  @javax.annotation.Nullable
  private Integer SMA;

  public static final String SERIALIZED_NAME_BUYING_POWER = "buyingPower";
  @SerializedName(SERIALIZED_NAME_BUYING_POWER)
  @javax.annotation.Nullable
  private Integer buyingPower;

  public static final String SERIALIZED_NAME_AVAILABLE_FUNDS = "availableFunds";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_FUNDS)
  @javax.annotation.Nullable
  private Integer availableFunds;

  public static final String SERIALIZED_NAME_EXCESS_LIQUIDITY = "excessLiquidity";
  @SerializedName(SERIALIZED_NAME_EXCESS_LIQUIDITY)
  @javax.annotation.Nullable
  private Integer excessLiquidity;

  public static final String SERIALIZED_NAME_NET_LIQUIDATION_VALUE = "netLiquidationValue";
  @SerializedName(SERIALIZED_NAME_NET_LIQUIDATION_VALUE)
  @javax.annotation.Nullable
  private Integer netLiquidationValue;

  public static final String SERIALIZED_NAME_EQUITY_WITH_LOAN_VALUE = "equityWithLoanValue";
  @SerializedName(SERIALIZED_NAME_EQUITY_WITH_LOAN_VALUE)
  @javax.annotation.Nullable
  private Integer equityWithLoanValue;

  public static final String SERIALIZED_NAME_REG_T_LOAN = "regTLoan";
  @SerializedName(SERIALIZED_NAME_REG_T_LOAN)
  @javax.annotation.Nullable
  private Integer regTLoan;

  public static final String SERIALIZED_NAME_SECURITIES_G_V_P = "securitiesGVP";
  @SerializedName(SERIALIZED_NAME_SECURITIES_G_V_P)
  @javax.annotation.Nullable
  private Integer securitiesGVP;

  public static final String SERIALIZED_NAME_TOTAL_CASH_VALUE = "totalCashValue";
  @SerializedName(SERIALIZED_NAME_TOTAL_CASH_VALUE)
  @javax.annotation.Nullable
  private Integer totalCashValue;

  public static final String SERIALIZED_NAME_ACCRUED_INTEREST = "accruedInterest";
  @SerializedName(SERIALIZED_NAME_ACCRUED_INTEREST)
  @javax.annotation.Nullable
  private Integer accruedInterest;

  public static final String SERIALIZED_NAME_REG_T_MARGIN = "regTMargin";
  @SerializedName(SERIALIZED_NAME_REG_T_MARGIN)
  @javax.annotation.Nullable
  private Integer regTMargin;

  public static final String SERIALIZED_NAME_INITIAL_MARGIN = "initialMargin";
  @SerializedName(SERIALIZED_NAME_INITIAL_MARGIN)
  @javax.annotation.Nullable
  private Integer initialMargin;

  public static final String SERIALIZED_NAME_MAINTENANCE_MARGIN = "maintenanceMargin";
  @SerializedName(SERIALIZED_NAME_MAINTENANCE_MARGIN)
  @javax.annotation.Nullable
  private Integer maintenanceMargin;

  public static final String SERIALIZED_NAME_CASH_BALANCES = "cashBalances";
  @SerializedName(SERIALIZED_NAME_CASH_BALANCES)
  @javax.annotation.Nullable
  private List<AccountSummaryResponseCashBalancesInner> cashBalances = new ArrayList<>();

  public AccountSummaryResponse() {
  }

  public AccountSummaryResponse accountType(@javax.annotation.Nullable String accountType) {
    this.accountType = accountType;
    return this;
  }

  /**
   * Describes the unique account type. For standard individual accounts, an empty string is returned.
   * @return accountType
   */
  @javax.annotation.Nullable
  public String getAccountType() {
    return accountType;
  }

  public void setAccountType(@javax.annotation.Nullable String accountType) {
    this.accountType = accountType;
  }


  public AccountSummaryResponse status(@javax.annotation.Nullable String status) {
    this.status = status;
    return this;
  }

  /**
   * If the account is currently non-tradeable, a status message will be dispalyed.
   * @return status
   */
  @javax.annotation.Nullable
  public String getStatus() {
    return status;
  }

  public void setStatus(@javax.annotation.Nullable String status) {
    this.status = status;
  }


  public AccountSummaryResponse balance(@javax.annotation.Nullable Integer balance) {
    this.balance = balance;
    return this;
  }

  /**
   * Returns the total account balance.
   * @return balance
   */
  @javax.annotation.Nullable
  public Integer getBalance() {
    return balance;
  }

  public void setBalance(@javax.annotation.Nullable Integer balance) {
    this.balance = balance;
  }


  public AccountSummaryResponse SMA(@javax.annotation.Nullable Integer SMA) {
    this.SMA = SMA;
    return this;
  }

  /**
   * Simple Moving Average of the account.
   * @return SMA
   */
  @javax.annotation.Nullable
  public Integer getSMA() {
    return SMA;
  }

  public void setSMA(@javax.annotation.Nullable Integer SMA) {
    this.SMA = SMA;
  }


  public AccountSummaryResponse buyingPower(@javax.annotation.Nullable Integer buyingPower) {
    this.buyingPower = buyingPower;
    return this;
  }

  /**
   * Total buying power available for the account.
   * @return buyingPower
   */
  @javax.annotation.Nullable
  public Integer getBuyingPower() {
    return buyingPower;
  }

  public void setBuyingPower(@javax.annotation.Nullable Integer buyingPower) {
    this.buyingPower = buyingPower;
  }


  public AccountSummaryResponse availableFunds(@javax.annotation.Nullable Integer availableFunds) {
    this.availableFunds = availableFunds;
    return this;
  }

  /**
   * The amount of equity you have available for trading. For both the Securities and Commodities segments, this is calculated as: Equity with Loan Value â€“ Initial Margin.
   * @return availableFunds
   */
  @javax.annotation.Nullable
  public Integer getAvailableFunds() {
    return availableFunds;
  }

  public void setAvailableFunds(@javax.annotation.Nullable Integer availableFunds) {
    this.availableFunds = availableFunds;
  }


  public AccountSummaryResponse excessLiquidity(@javax.annotation.Nullable Integer excessLiquidity) {
    this.excessLiquidity = excessLiquidity;
    return this;
  }

  /**
   * The amount of cash in excess of the usual requirement in your account.
   * @return excessLiquidity
   */
  @javax.annotation.Nullable
  public Integer getExcessLiquidity() {
    return excessLiquidity;
  }

  public void setExcessLiquidity(@javax.annotation.Nullable Integer excessLiquidity) {
    this.excessLiquidity = excessLiquidity;
  }


  public AccountSummaryResponse netLiquidationValue(@javax.annotation.Nullable Integer netLiquidationValue) {
    this.netLiquidationValue = netLiquidationValue;
    return this;
  }

  /**
   * The basis for determining the price of the assets in your account.
   * @return netLiquidationValue
   */
  @javax.annotation.Nullable
  public Integer getNetLiquidationValue() {
    return netLiquidationValue;
  }

  public void setNetLiquidationValue(@javax.annotation.Nullable Integer netLiquidationValue) {
    this.netLiquidationValue = netLiquidationValue;
  }


  public AccountSummaryResponse equityWithLoanValue(@javax.annotation.Nullable Integer equityWithLoanValue) {
    this.equityWithLoanValue = equityWithLoanValue;
    return this;
  }

  /**
   * The basis for determining whether you have the necessary assets to either initiate or maintain security assets.
   * @return equityWithLoanValue
   */
  @javax.annotation.Nullable
  public Integer getEquityWithLoanValue() {
    return equityWithLoanValue;
  }

  public void setEquityWithLoanValue(@javax.annotation.Nullable Integer equityWithLoanValue) {
    this.equityWithLoanValue = equityWithLoanValue;
  }


  public AccountSummaryResponse regTLoan(@javax.annotation.Nullable Integer regTLoan) {
    this.regTLoan = regTLoan;
    return this;
  }

  /**
   * The Federal Reserve Board regulation governing the amount of credit that broker dealers may extend to clients who borrow money to buy securities on margin.
   * @return regTLoan
   */
  @javax.annotation.Nullable
  public Integer getRegTLoan() {
    return regTLoan;
  }

  public void setRegTLoan(@javax.annotation.Nullable Integer regTLoan) {
    this.regTLoan = regTLoan;
  }


  public AccountSummaryResponse securitiesGVP(@javax.annotation.Nullable Integer securitiesGVP) {
    this.securitiesGVP = securitiesGVP;
    return this;
  }

  /**
   * Absolute value of the Long Stock Value + Short Stock Value + Long Option Value + Short Option Value + Fund Value.
   * @return securitiesGVP
   */
  @javax.annotation.Nullable
  public Integer getSecuritiesGVP() {
    return securitiesGVP;
  }

  public void setSecuritiesGVP(@javax.annotation.Nullable Integer securitiesGVP) {
    this.securitiesGVP = securitiesGVP;
  }


  public AccountSummaryResponse totalCashValue(@javax.annotation.Nullable Integer totalCashValue) {
    this.totalCashValue = totalCashValue;
    return this;
  }

  /**
   * Cash recognized at the time of trade + futures P&amp;L. This value reflects real-time currency positions, including:  *  Trades executed directly through the FX market.  *  Trades executed as a result of automatic IB conversions, which occur when you trade a product in a non-base currency.  *  Trades deliberately executed to close non-base currency positions using the FXCONV destination. 
   * @return totalCashValue
   */
  @javax.annotation.Nullable
  public Integer getTotalCashValue() {
    return totalCashValue;
  }

  public void setTotalCashValue(@javax.annotation.Nullable Integer totalCashValue) {
    this.totalCashValue = totalCashValue;
  }


  public AccountSummaryResponse accruedInterest(@javax.annotation.Nullable Integer accruedInterest) {
    this.accruedInterest = accruedInterest;
    return this;
  }

  /**
   * Accrued interest is the interest accruing on a security since the previous coupon date. If a security is sold between two payment dates, the buyer usually compensates the seller for the interest accrued, either within the price or as a separate payment.
   * @return accruedInterest
   */
  @javax.annotation.Nullable
  public Integer getAccruedInterest() {
    return accruedInterest;
  }

  public void setAccruedInterest(@javax.annotation.Nullable Integer accruedInterest) {
    this.accruedInterest = accruedInterest;
  }


  public AccountSummaryResponse regTMargin(@javax.annotation.Nullable Integer regTMargin) {
    this.regTMargin = regTMargin;
    return this;
  }

  /**
   * The initial margin requirements calculated under US Regulation T rules for both the securities and commodities segment of your account.
   * @return regTMargin
   */
  @javax.annotation.Nullable
  public Integer getRegTMargin() {
    return regTMargin;
  }

  public void setRegTMargin(@javax.annotation.Nullable Integer regTMargin) {
    this.regTMargin = regTMargin;
  }


  public AccountSummaryResponse initialMargin(@javax.annotation.Nullable Integer initialMargin) {
    this.initialMargin = initialMargin;
    return this;
  }

  /**
   * The available initial margin for the account.
   * @return initialMargin
   */
  @javax.annotation.Nullable
  public Integer getInitialMargin() {
    return initialMargin;
  }

  public void setInitialMargin(@javax.annotation.Nullable Integer initialMargin) {
    this.initialMargin = initialMargin;
  }


  public AccountSummaryResponse maintenanceMargin(@javax.annotation.Nullable Integer maintenanceMargin) {
    this.maintenanceMargin = maintenanceMargin;
    return this;
  }

  /**
   * The available maintenance margin for the account.
   * @return maintenanceMargin
   */
  @javax.annotation.Nullable
  public Integer getMaintenanceMargin() {
    return maintenanceMargin;
  }

  public void setMaintenanceMargin(@javax.annotation.Nullable Integer maintenanceMargin) {
    this.maintenanceMargin = maintenanceMargin;
  }


  public AccountSummaryResponse cashBalances(@javax.annotation.Nullable List<AccountSummaryResponseCashBalancesInner> cashBalances) {
    this.cashBalances = cashBalances;
    return this;
  }

  public AccountSummaryResponse addCashBalancesItem(AccountSummaryResponseCashBalancesInner cashBalancesItem) {
    if (this.cashBalances == null) {
      this.cashBalances = new ArrayList<>();
    }
    this.cashBalances.add(cashBalancesItem);
    return this;
  }

  /**
   * An array containing balance information for all currencies held by the account.
   * @return cashBalances
   */
  @javax.annotation.Nullable
  public List<AccountSummaryResponseCashBalancesInner> getCashBalances() {
    return cashBalances;
  }

  public void setCashBalances(@javax.annotation.Nullable List<AccountSummaryResponseCashBalancesInner> cashBalances) {
    this.cashBalances = cashBalances;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AccountSummaryResponse accountSummaryResponse = (AccountSummaryResponse) o;
    return Objects.equals(this.accountType, accountSummaryResponse.accountType) &&
        Objects.equals(this.status, accountSummaryResponse.status) &&
        Objects.equals(this.balance, accountSummaryResponse.balance) &&
        Objects.equals(this.SMA, accountSummaryResponse.SMA) &&
        Objects.equals(this.buyingPower, accountSummaryResponse.buyingPower) &&
        Objects.equals(this.availableFunds, accountSummaryResponse.availableFunds) &&
        Objects.equals(this.excessLiquidity, accountSummaryResponse.excessLiquidity) &&
        Objects.equals(this.netLiquidationValue, accountSummaryResponse.netLiquidationValue) &&
        Objects.equals(this.equityWithLoanValue, accountSummaryResponse.equityWithLoanValue) &&
        Objects.equals(this.regTLoan, accountSummaryResponse.regTLoan) &&
        Objects.equals(this.securitiesGVP, accountSummaryResponse.securitiesGVP) &&
        Objects.equals(this.totalCashValue, accountSummaryResponse.totalCashValue) &&
        Objects.equals(this.accruedInterest, accountSummaryResponse.accruedInterest) &&
        Objects.equals(this.regTMargin, accountSummaryResponse.regTMargin) &&
        Objects.equals(this.initialMargin, accountSummaryResponse.initialMargin) &&
        Objects.equals(this.maintenanceMargin, accountSummaryResponse.maintenanceMargin) &&
        Objects.equals(this.cashBalances, accountSummaryResponse.cashBalances);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountType, status, balance, SMA, buyingPower, availableFunds, excessLiquidity, netLiquidationValue, equityWithLoanValue, regTLoan, securitiesGVP, totalCashValue, accruedInterest, regTMargin, initialMargin, maintenanceMargin, cashBalances);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AccountSummaryResponse {\n");
    sb.append("    accountType: ").append(toIndentedString(accountType)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    balance: ").append(toIndentedString(balance)).append("\n");
    sb.append("    SMA: ").append(toIndentedString(SMA)).append("\n");
    sb.append("    buyingPower: ").append(toIndentedString(buyingPower)).append("\n");
    sb.append("    availableFunds: ").append(toIndentedString(availableFunds)).append("\n");
    sb.append("    excessLiquidity: ").append(toIndentedString(excessLiquidity)).append("\n");
    sb.append("    netLiquidationValue: ").append(toIndentedString(netLiquidationValue)).append("\n");
    sb.append("    equityWithLoanValue: ").append(toIndentedString(equityWithLoanValue)).append("\n");
    sb.append("    regTLoan: ").append(toIndentedString(regTLoan)).append("\n");
    sb.append("    securitiesGVP: ").append(toIndentedString(securitiesGVP)).append("\n");
    sb.append("    totalCashValue: ").append(toIndentedString(totalCashValue)).append("\n");
    sb.append("    accruedInterest: ").append(toIndentedString(accruedInterest)).append("\n");
    sb.append("    regTMargin: ").append(toIndentedString(regTMargin)).append("\n");
    sb.append("    initialMargin: ").append(toIndentedString(initialMargin)).append("\n");
    sb.append("    maintenanceMargin: ").append(toIndentedString(maintenanceMargin)).append("\n");
    sb.append("    cashBalances: ").append(toIndentedString(cashBalances)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accountType");
    openapiFields.add("status");
    openapiFields.add("balance");
    openapiFields.add("SMA");
    openapiFields.add("buyingPower");
    openapiFields.add("availableFunds");
    openapiFields.add("excessLiquidity");
    openapiFields.add("netLiquidationValue");
    openapiFields.add("equityWithLoanValue");
    openapiFields.add("regTLoan");
    openapiFields.add("securitiesGVP");
    openapiFields.add("totalCashValue");
    openapiFields.add("accruedInterest");
    openapiFields.add("regTMargin");
    openapiFields.add("initialMargin");
    openapiFields.add("maintenanceMargin");
    openapiFields.add("cashBalances");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AccountSummaryResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AccountSummaryResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AccountSummaryResponse is not found in the empty JSON string", AccountSummaryResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AccountSummaryResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AccountSummaryResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("accountType") != null && !jsonObj.get("accountType").isJsonNull()) && !jsonObj.get("accountType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accountType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accountType").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      if (jsonObj.get("cashBalances") != null && !jsonObj.get("cashBalances").isJsonNull()) {
        JsonArray jsonArraycashBalances = jsonObj.getAsJsonArray("cashBalances");
        if (jsonArraycashBalances != null) {
          // ensure the json data is an array
          if (!jsonObj.get("cashBalances").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `cashBalances` to be an array in the JSON string but got `%s`", jsonObj.get("cashBalances").toString()));
          }

          // validate the optional field `cashBalances` (array)
          for (int i = 0; i < jsonArraycashBalances.size(); i++) {
            AccountSummaryResponseCashBalancesInner.validateJsonElement(jsonArraycashBalances.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AccountSummaryResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AccountSummaryResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AccountSummaryResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AccountSummaryResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<AccountSummaryResponse>() {
           @Override
           public void write(JsonWriter out, AccountSummaryResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AccountSummaryResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AccountSummaryResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AccountSummaryResponse
   * @throws IOException if the JSON string is invalid with respect to AccountSummaryResponse
   */
  public static AccountSummaryResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AccountSummaryResponse.class);
  }

  /**
   * Convert an instance of AccountSummaryResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

