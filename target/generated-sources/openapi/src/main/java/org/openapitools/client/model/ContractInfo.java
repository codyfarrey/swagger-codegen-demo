/*
 * IB REST API
 * The IB REST API reference documentation
 *
 * The version of the OpenAPI document: 2.13.0
 * Contact: api@interactivebrokers.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * ContractInfo
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-03-18T20:44:00.611784800-05:00[America/Chicago]", comments = "Generator version: 7.12.0")
public class ContractInfo {
  public static final String SERIALIZED_NAME_CFI_CODE = "cfi_code";
  @SerializedName(SERIALIZED_NAME_CFI_CODE)
  @javax.annotation.Nullable
  private String cfiCode;

  public static final String SERIALIZED_NAME_SYMBOL = "symbol";
  @SerializedName(SERIALIZED_NAME_SYMBOL)
  @javax.annotation.Nullable
  private String symbol;

  public static final String SERIALIZED_NAME_CUSIP = "cusip";
  @SerializedName(SERIALIZED_NAME_CUSIP)
  @javax.annotation.Nullable
  private String cusip;

  public static final String SERIALIZED_NAME_EXPIRY_FULL = "expiry_full";
  @SerializedName(SERIALIZED_NAME_EXPIRY_FULL)
  @javax.annotation.Nullable
  private String expiryFull;

  public static final String SERIALIZED_NAME_CON_ID = "con_id";
  @SerializedName(SERIALIZED_NAME_CON_ID)
  @javax.annotation.Nullable
  private Integer conId;

  public static final String SERIALIZED_NAME_MATURITY_DATE = "maturity_date";
  @SerializedName(SERIALIZED_NAME_MATURITY_DATE)
  @javax.annotation.Nullable
  private String maturityDate;

  public static final String SERIALIZED_NAME_INDUSTRY = "industry";
  @SerializedName(SERIALIZED_NAME_INDUSTRY)
  @javax.annotation.Nullable
  private String industry;

  public static final String SERIALIZED_NAME_INSTRUMENT_TYPE = "instrument_type";
  @SerializedName(SERIALIZED_NAME_INSTRUMENT_TYPE)
  @javax.annotation.Nullable
  private String instrumentType;

  public static final String SERIALIZED_NAME_TRADING_CLASS = "trading_class";
  @SerializedName(SERIALIZED_NAME_TRADING_CLASS)
  @javax.annotation.Nullable
  private String tradingClass;

  public static final String SERIALIZED_NAME_VALID_EXCHANGES = "valid_exchanges";
  @SerializedName(SERIALIZED_NAME_VALID_EXCHANGES)
  @javax.annotation.Nullable
  private String validExchanges;

  public static final String SERIALIZED_NAME_ALLOW_SELL_LONG = "allow_sell_long";
  @SerializedName(SERIALIZED_NAME_ALLOW_SELL_LONG)
  @javax.annotation.Nullable
  private Boolean allowSellLong;

  public static final String SERIALIZED_NAME_IS_ZERO_COMMISSION_SECURITY = "is_zero_commission_security";
  @SerializedName(SERIALIZED_NAME_IS_ZERO_COMMISSION_SECURITY)
  @javax.annotation.Nullable
  private Boolean isZeroCommissionSecurity;

  public static final String SERIALIZED_NAME_LOCAL_SYMBOL = "local_symbol";
  @SerializedName(SERIALIZED_NAME_LOCAL_SYMBOL)
  @javax.annotation.Nullable
  private String localSymbol;

  public static final String SERIALIZED_NAME_CONTRACT_CLARIFICATION_TYPE = "contract_clarification_type";
  @SerializedName(SERIALIZED_NAME_CONTRACT_CLARIFICATION_TYPE)
  @javax.annotation.Nullable
  private String contractClarificationType;

  public static final String SERIALIZED_NAME_CLASSIFIER = "classifier";
  @SerializedName(SERIALIZED_NAME_CLASSIFIER)
  @javax.annotation.Nullable
  private String classifier;

  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  @javax.annotation.Nullable
  private String currency;

  public static final String SERIALIZED_NAME_TEXT = "text";
  @SerializedName(SERIALIZED_NAME_TEXT)
  @javax.annotation.Nullable
  private String text;

  public static final String SERIALIZED_NAME_UNDERLYING_CON_ID = "underlying_con_id";
  @SerializedName(SERIALIZED_NAME_UNDERLYING_CON_ID)
  @javax.annotation.Nullable
  private Integer underlyingConId;

  public static final String SERIALIZED_NAME_R_T_H = "r_t_h";
  @SerializedName(SERIALIZED_NAME_R_T_H)
  @javax.annotation.Nullable
  private Boolean rTH;

  public static final String SERIALIZED_NAME_MULTIPLIER = "multiplier";
  @SerializedName(SERIALIZED_NAME_MULTIPLIER)
  @javax.annotation.Nullable
  private String multiplier;

  public static final String SERIALIZED_NAME_UNDERLYING_ISSUER = "underlying_issuer";
  @SerializedName(SERIALIZED_NAME_UNDERLYING_ISSUER)
  @javax.annotation.Nullable
  private String underlyingIssuer;

  public static final String SERIALIZED_NAME_CONTRACT_MONTH = "contract_month";
  @SerializedName(SERIALIZED_NAME_CONTRACT_MONTH)
  @javax.annotation.Nullable
  private String contractMonth;

  public static final String SERIALIZED_NAME_COMPANY_NAME = "company_name";
  @SerializedName(SERIALIZED_NAME_COMPANY_NAME)
  @javax.annotation.Nullable
  private String companyName;

  public static final String SERIALIZED_NAME_SMART_AVAILABLE = "smart_available";
  @SerializedName(SERIALIZED_NAME_SMART_AVAILABLE)
  @javax.annotation.Nullable
  private Boolean smartAvailable;

  public static final String SERIALIZED_NAME_EXCHANGE = "exchange";
  @SerializedName(SERIALIZED_NAME_EXCHANGE)
  @javax.annotation.Nullable
  private String exchange;

  public static final String SERIALIZED_NAME_CATEGORY = "category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  @javax.annotation.Nullable
  private String category;

  public ContractInfo() {
  }

  public ContractInfo cfiCode(@javax.annotation.Nullable String cfiCode) {
    this.cfiCode = cfiCode;
    return this;
  }

  /**
   * Classification of Financial Instrument codes
   * @return cfiCode
   */
  @javax.annotation.Nullable
  public String getCfiCode() {
    return cfiCode;
  }

  public void setCfiCode(@javax.annotation.Nullable String cfiCode) {
    this.cfiCode = cfiCode;
  }


  public ContractInfo symbol(@javax.annotation.Nullable String symbol) {
    this.symbol = symbol;
    return this;
  }

  /**
   * Underlying symbol
   * @return symbol
   */
  @javax.annotation.Nullable
  public String getSymbol() {
    return symbol;
  }

  public void setSymbol(@javax.annotation.Nullable String symbol) {
    this.symbol = symbol;
  }


  public ContractInfo cusip(@javax.annotation.Nullable String cusip) {
    this.cusip = cusip;
    return this;
  }

  /**
   * Returns the CUSIP for the given instrument. Only used in BOND trading.
   * @return cusip
   */
  @javax.annotation.Nullable
  public String getCusip() {
    return cusip;
  }

  public void setCusip(@javax.annotation.Nullable String cusip) {
    this.cusip = cusip;
  }


  public ContractInfo expiryFull(@javax.annotation.Nullable String expiryFull) {
    this.expiryFull = expiryFull;
    return this;
  }

  /**
   * Returns the expiration month of the contract.
   * @return expiryFull
   */
  @javax.annotation.Nullable
  public String getExpiryFull() {
    return expiryFull;
  }

  public void setExpiryFull(@javax.annotation.Nullable String expiryFull) {
    this.expiryFull = expiryFull;
  }


  public ContractInfo conId(@javax.annotation.Nullable Integer conId) {
    this.conId = conId;
    return this;
  }

  /**
   * Indicates the contract identifier of the given contract.
   * @return conId
   */
  @javax.annotation.Nullable
  public Integer getConId() {
    return conId;
  }

  public void setConId(@javax.annotation.Nullable Integer conId) {
    this.conId = conId;
  }


  public ContractInfo maturityDate(@javax.annotation.Nullable String maturityDate) {
    this.maturityDate = maturityDate;
    return this;
  }

  /**
   * Indicates the final maturity date of the given contract.
   * @return maturityDate
   */
  @javax.annotation.Nullable
  public String getMaturityDate() {
    return maturityDate;
  }

  public void setMaturityDate(@javax.annotation.Nullable String maturityDate) {
    this.maturityDate = maturityDate;
  }


  public ContractInfo industry(@javax.annotation.Nullable String industry) {
    this.industry = industry;
    return this;
  }

  /**
   * Specific group of companies or businesses.
   * @return industry
   */
  @javax.annotation.Nullable
  public String getIndustry() {
    return industry;
  }

  public void setIndustry(@javax.annotation.Nullable String industry) {
    this.industry = industry;
  }


  public ContractInfo instrumentType(@javax.annotation.Nullable String instrumentType) {
    this.instrumentType = instrumentType;
    return this;
  }

  /**
   * Asset class of the instrument.
   * @return instrumentType
   */
  @javax.annotation.Nullable
  public String getInstrumentType() {
    return instrumentType;
  }

  public void setInstrumentType(@javax.annotation.Nullable String instrumentType) {
    this.instrumentType = instrumentType;
  }


  public ContractInfo tradingClass(@javax.annotation.Nullable String tradingClass) {
    this.tradingClass = tradingClass;
    return this;
  }

  /**
   * Designated trading class of the contract.
   * @return tradingClass
   */
  @javax.annotation.Nullable
  public String getTradingClass() {
    return tradingClass;
  }

  public void setTradingClass(@javax.annotation.Nullable String tradingClass) {
    this.tradingClass = tradingClass;
  }


  public ContractInfo validExchanges(@javax.annotation.Nullable String validExchanges) {
    this.validExchanges = validExchanges;
    return this;
  }

  /**
   * Comma separated list of support exchanges or trading venues.
   * @return validExchanges
   */
  @javax.annotation.Nullable
  public String getValidExchanges() {
    return validExchanges;
  }

  public void setValidExchanges(@javax.annotation.Nullable String validExchanges) {
    this.validExchanges = validExchanges;
  }


  public ContractInfo allowSellLong(@javax.annotation.Nullable Boolean allowSellLong) {
    this.allowSellLong = allowSellLong;
    return this;
  }

  /**
   * Allowed to sell shares you own.
   * @return allowSellLong
   */
  @javax.annotation.Nullable
  public Boolean getAllowSellLong() {
    return allowSellLong;
  }

  public void setAllowSellLong(@javax.annotation.Nullable Boolean allowSellLong) {
    this.allowSellLong = allowSellLong;
  }


  public ContractInfo isZeroCommissionSecurity(@javax.annotation.Nullable Boolean isZeroCommissionSecurity) {
    this.isZeroCommissionSecurity = isZeroCommissionSecurity;
    return this;
  }

  /**
   * Indicates if the contract supports zero commission trading.
   * @return isZeroCommissionSecurity
   */
  @javax.annotation.Nullable
  public Boolean getIsZeroCommissionSecurity() {
    return isZeroCommissionSecurity;
  }

  public void setIsZeroCommissionSecurity(@javax.annotation.Nullable Boolean isZeroCommissionSecurity) {
    this.isZeroCommissionSecurity = isZeroCommissionSecurity;
  }


  public ContractInfo localSymbol(@javax.annotation.Nullable String localSymbol) {
    this.localSymbol = localSymbol;
    return this;
  }

  /**
   * Contractâ€™s symbol from primary exchange. For options it is the OCC symbol.
   * @return localSymbol
   */
  @javax.annotation.Nullable
  public String getLocalSymbol() {
    return localSymbol;
  }

  public void setLocalSymbol(@javax.annotation.Nullable String localSymbol) {
    this.localSymbol = localSymbol;
  }


  public ContractInfo contractClarificationType(@javax.annotation.Nullable String contractClarificationType) {
    this.contractClarificationType = contractClarificationType;
    return this;
  }

  /**
   * Get contractClarificationType
   * @return contractClarificationType
   */
  @javax.annotation.Nullable
  public String getContractClarificationType() {
    return contractClarificationType;
  }

  public void setContractClarificationType(@javax.annotation.Nullable String contractClarificationType) {
    this.contractClarificationType = contractClarificationType;
  }


  public ContractInfo classifier(@javax.annotation.Nullable String classifier) {
    this.classifier = classifier;
    return this;
  }

  /**
   * Get classifier
   * @return classifier
   */
  @javax.annotation.Nullable
  public String getClassifier() {
    return classifier;
  }

  public void setClassifier(@javax.annotation.Nullable String classifier) {
    this.classifier = classifier;
  }


  public ContractInfo currency(@javax.annotation.Nullable String currency) {
    this.currency = currency;
    return this;
  }

  /**
   * Base currency contract is traded in.
   * @return currency
   */
  @javax.annotation.Nullable
  public String getCurrency() {
    return currency;
  }

  public void setCurrency(@javax.annotation.Nullable String currency) {
    this.currency = currency;
  }


  public ContractInfo text(@javax.annotation.Nullable String text) {
    this.text = text;
    return this;
  }

  /**
   * Indicates the display name of the contract, as shown with Client Portal.
   * @return text
   */
  @javax.annotation.Nullable
  public String getText() {
    return text;
  }

  public void setText(@javax.annotation.Nullable String text) {
    this.text = text;
  }


  public ContractInfo underlyingConId(@javax.annotation.Nullable Integer underlyingConId) {
    this.underlyingConId = underlyingConId;
    return this;
  }

  /**
   * Underlying contract identifier for the requested contract.
   * @return underlyingConId
   */
  @javax.annotation.Nullable
  public Integer getUnderlyingConId() {
    return underlyingConId;
  }

  public void setUnderlyingConId(@javax.annotation.Nullable Integer underlyingConId) {
    this.underlyingConId = underlyingConId;
  }


  public ContractInfo rTH(@javax.annotation.Nullable Boolean rTH) {
    this.rTH = rTH;
    return this;
  }

  /**
   * Indicates if the contract can be traded outside regular trading hours or not.
   * @return rTH
   */
  @javax.annotation.Nullable
  public Boolean getrTH() {
    return rTH;
  }

  public void setrTH(@javax.annotation.Nullable Boolean rTH) {
    this.rTH = rTH;
  }


  public ContractInfo multiplier(@javax.annotation.Nullable String multiplier) {
    this.multiplier = multiplier;
    return this;
  }

  /**
   * Indicates the multiplier of the contract.
   * @return multiplier
   */
  @javax.annotation.Nullable
  public String getMultiplier() {
    return multiplier;
  }

  public void setMultiplier(@javax.annotation.Nullable String multiplier) {
    this.multiplier = multiplier;
  }


  public ContractInfo underlyingIssuer(@javax.annotation.Nullable String underlyingIssuer) {
    this.underlyingIssuer = underlyingIssuer;
    return this;
  }

  /**
   * Indicates the issuer of the underlying.
   * @return underlyingIssuer
   */
  @javax.annotation.Nullable
  public String getUnderlyingIssuer() {
    return underlyingIssuer;
  }

  public void setUnderlyingIssuer(@javax.annotation.Nullable String underlyingIssuer) {
    this.underlyingIssuer = underlyingIssuer;
  }


  public ContractInfo contractMonth(@javax.annotation.Nullable String contractMonth) {
    this.contractMonth = contractMonth;
    return this;
  }

  /**
   * Indicates the year and month the contract expires.
   * @return contractMonth
   */
  @javax.annotation.Nullable
  public String getContractMonth() {
    return contractMonth;
  }

  public void setContractMonth(@javax.annotation.Nullable String contractMonth) {
    this.contractMonth = contractMonth;
  }


  public ContractInfo companyName(@javax.annotation.Nullable String companyName) {
    this.companyName = companyName;
    return this;
  }

  /**
   * Indicates the name of the company or index.
   * @return companyName
   */
  @javax.annotation.Nullable
  public String getCompanyName() {
    return companyName;
  }

  public void setCompanyName(@javax.annotation.Nullable String companyName) {
    this.companyName = companyName;
  }


  public ContractInfo smartAvailable(@javax.annotation.Nullable Boolean smartAvailable) {
    this.smartAvailable = smartAvailable;
    return this;
  }

  /**
   * Indicates if the contract can be smart routed or not.
   * @return smartAvailable
   */
  @javax.annotation.Nullable
  public Boolean getSmartAvailable() {
    return smartAvailable;
  }

  public void setSmartAvailable(@javax.annotation.Nullable Boolean smartAvailable) {
    this.smartAvailable = smartAvailable;
  }


  public ContractInfo exchange(@javax.annotation.Nullable String exchange) {
    this.exchange = exchange;
    return this;
  }

  /**
   * Indicates the primary exchange for which the contract can be traded.
   * @return exchange
   */
  @javax.annotation.Nullable
  public String getExchange() {
    return exchange;
  }

  public void setExchange(@javax.annotation.Nullable String exchange) {
    this.exchange = exchange;
  }


  public ContractInfo category(@javax.annotation.Nullable String category) {
    this.category = category;
    return this;
  }

  /**
   * Indicates the industry category of the instrument.
   * @return category
   */
  @javax.annotation.Nullable
  public String getCategory() {
    return category;
  }

  public void setCategory(@javax.annotation.Nullable String category) {
    this.category = category;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ContractInfo contractInfo = (ContractInfo) o;
    return Objects.equals(this.cfiCode, contractInfo.cfiCode) &&
        Objects.equals(this.symbol, contractInfo.symbol) &&
        Objects.equals(this.cusip, contractInfo.cusip) &&
        Objects.equals(this.expiryFull, contractInfo.expiryFull) &&
        Objects.equals(this.conId, contractInfo.conId) &&
        Objects.equals(this.maturityDate, contractInfo.maturityDate) &&
        Objects.equals(this.industry, contractInfo.industry) &&
        Objects.equals(this.instrumentType, contractInfo.instrumentType) &&
        Objects.equals(this.tradingClass, contractInfo.tradingClass) &&
        Objects.equals(this.validExchanges, contractInfo.validExchanges) &&
        Objects.equals(this.allowSellLong, contractInfo.allowSellLong) &&
        Objects.equals(this.isZeroCommissionSecurity, contractInfo.isZeroCommissionSecurity) &&
        Objects.equals(this.localSymbol, contractInfo.localSymbol) &&
        Objects.equals(this.contractClarificationType, contractInfo.contractClarificationType) &&
        Objects.equals(this.classifier, contractInfo.classifier) &&
        Objects.equals(this.currency, contractInfo.currency) &&
        Objects.equals(this.text, contractInfo.text) &&
        Objects.equals(this.underlyingConId, contractInfo.underlyingConId) &&
        Objects.equals(this.rTH, contractInfo.rTH) &&
        Objects.equals(this.multiplier, contractInfo.multiplier) &&
        Objects.equals(this.underlyingIssuer, contractInfo.underlyingIssuer) &&
        Objects.equals(this.contractMonth, contractInfo.contractMonth) &&
        Objects.equals(this.companyName, contractInfo.companyName) &&
        Objects.equals(this.smartAvailable, contractInfo.smartAvailable) &&
        Objects.equals(this.exchange, contractInfo.exchange) &&
        Objects.equals(this.category, contractInfo.category);
  }

  @Override
  public int hashCode() {
    return Objects.hash(cfiCode, symbol, cusip, expiryFull, conId, maturityDate, industry, instrumentType, tradingClass, validExchanges, allowSellLong, isZeroCommissionSecurity, localSymbol, contractClarificationType, classifier, currency, text, underlyingConId, rTH, multiplier, underlyingIssuer, contractMonth, companyName, smartAvailable, exchange, category);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ContractInfo {\n");
    sb.append("    cfiCode: ").append(toIndentedString(cfiCode)).append("\n");
    sb.append("    symbol: ").append(toIndentedString(symbol)).append("\n");
    sb.append("    cusip: ").append(toIndentedString(cusip)).append("\n");
    sb.append("    expiryFull: ").append(toIndentedString(expiryFull)).append("\n");
    sb.append("    conId: ").append(toIndentedString(conId)).append("\n");
    sb.append("    maturityDate: ").append(toIndentedString(maturityDate)).append("\n");
    sb.append("    industry: ").append(toIndentedString(industry)).append("\n");
    sb.append("    instrumentType: ").append(toIndentedString(instrumentType)).append("\n");
    sb.append("    tradingClass: ").append(toIndentedString(tradingClass)).append("\n");
    sb.append("    validExchanges: ").append(toIndentedString(validExchanges)).append("\n");
    sb.append("    allowSellLong: ").append(toIndentedString(allowSellLong)).append("\n");
    sb.append("    isZeroCommissionSecurity: ").append(toIndentedString(isZeroCommissionSecurity)).append("\n");
    sb.append("    localSymbol: ").append(toIndentedString(localSymbol)).append("\n");
    sb.append("    contractClarificationType: ").append(toIndentedString(contractClarificationType)).append("\n");
    sb.append("    classifier: ").append(toIndentedString(classifier)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    text: ").append(toIndentedString(text)).append("\n");
    sb.append("    underlyingConId: ").append(toIndentedString(underlyingConId)).append("\n");
    sb.append("    rTH: ").append(toIndentedString(rTH)).append("\n");
    sb.append("    multiplier: ").append(toIndentedString(multiplier)).append("\n");
    sb.append("    underlyingIssuer: ").append(toIndentedString(underlyingIssuer)).append("\n");
    sb.append("    contractMonth: ").append(toIndentedString(contractMonth)).append("\n");
    sb.append("    companyName: ").append(toIndentedString(companyName)).append("\n");
    sb.append("    smartAvailable: ").append(toIndentedString(smartAvailable)).append("\n");
    sb.append("    exchange: ").append(toIndentedString(exchange)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("cfi_code");
    openapiFields.add("symbol");
    openapiFields.add("cusip");
    openapiFields.add("expiry_full");
    openapiFields.add("con_id");
    openapiFields.add("maturity_date");
    openapiFields.add("industry");
    openapiFields.add("instrument_type");
    openapiFields.add("trading_class");
    openapiFields.add("valid_exchanges");
    openapiFields.add("allow_sell_long");
    openapiFields.add("is_zero_commission_security");
    openapiFields.add("local_symbol");
    openapiFields.add("contract_clarification_type");
    openapiFields.add("classifier");
    openapiFields.add("currency");
    openapiFields.add("text");
    openapiFields.add("underlying_con_id");
    openapiFields.add("r_t_h");
    openapiFields.add("multiplier");
    openapiFields.add("underlying_issuer");
    openapiFields.add("contract_month");
    openapiFields.add("company_name");
    openapiFields.add("smart_available");
    openapiFields.add("exchange");
    openapiFields.add("category");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ContractInfo
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ContractInfo.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ContractInfo is not found in the empty JSON string", ContractInfo.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ContractInfo.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ContractInfo` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("cfi_code") != null && !jsonObj.get("cfi_code").isJsonNull()) && !jsonObj.get("cfi_code").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cfi_code` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cfi_code").toString()));
      }
      if ((jsonObj.get("symbol") != null && !jsonObj.get("symbol").isJsonNull()) && !jsonObj.get("symbol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `symbol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("symbol").toString()));
      }
      if ((jsonObj.get("cusip") != null && !jsonObj.get("cusip").isJsonNull()) && !jsonObj.get("cusip").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cusip` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cusip").toString()));
      }
      if ((jsonObj.get("expiry_full") != null && !jsonObj.get("expiry_full").isJsonNull()) && !jsonObj.get("expiry_full").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `expiry_full` to be a primitive type in the JSON string but got `%s`", jsonObj.get("expiry_full").toString()));
      }
      if ((jsonObj.get("maturity_date") != null && !jsonObj.get("maturity_date").isJsonNull()) && !jsonObj.get("maturity_date").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maturity_date` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maturity_date").toString()));
      }
      if ((jsonObj.get("industry") != null && !jsonObj.get("industry").isJsonNull()) && !jsonObj.get("industry").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `industry` to be a primitive type in the JSON string but got `%s`", jsonObj.get("industry").toString()));
      }
      if ((jsonObj.get("instrument_type") != null && !jsonObj.get("instrument_type").isJsonNull()) && !jsonObj.get("instrument_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `instrument_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("instrument_type").toString()));
      }
      if ((jsonObj.get("trading_class") != null && !jsonObj.get("trading_class").isJsonNull()) && !jsonObj.get("trading_class").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `trading_class` to be a primitive type in the JSON string but got `%s`", jsonObj.get("trading_class").toString()));
      }
      if ((jsonObj.get("valid_exchanges") != null && !jsonObj.get("valid_exchanges").isJsonNull()) && !jsonObj.get("valid_exchanges").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `valid_exchanges` to be a primitive type in the JSON string but got `%s`", jsonObj.get("valid_exchanges").toString()));
      }
      if ((jsonObj.get("local_symbol") != null && !jsonObj.get("local_symbol").isJsonNull()) && !jsonObj.get("local_symbol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `local_symbol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("local_symbol").toString()));
      }
      if ((jsonObj.get("contract_clarification_type") != null && !jsonObj.get("contract_clarification_type").isJsonNull()) && !jsonObj.get("contract_clarification_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contract_clarification_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contract_clarification_type").toString()));
      }
      if ((jsonObj.get("classifier") != null && !jsonObj.get("classifier").isJsonNull()) && !jsonObj.get("classifier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `classifier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("classifier").toString()));
      }
      if ((jsonObj.get("currency") != null && !jsonObj.get("currency").isJsonNull()) && !jsonObj.get("currency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currency").toString()));
      }
      if ((jsonObj.get("text") != null && !jsonObj.get("text").isJsonNull()) && !jsonObj.get("text").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `text` to be a primitive type in the JSON string but got `%s`", jsonObj.get("text").toString()));
      }
      if ((jsonObj.get("multiplier") != null && !jsonObj.get("multiplier").isJsonNull()) && !jsonObj.get("multiplier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `multiplier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("multiplier").toString()));
      }
      if ((jsonObj.get("underlying_issuer") != null && !jsonObj.get("underlying_issuer").isJsonNull()) && !jsonObj.get("underlying_issuer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `underlying_issuer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("underlying_issuer").toString()));
      }
      if ((jsonObj.get("contract_month") != null && !jsonObj.get("contract_month").isJsonNull()) && !jsonObj.get("contract_month").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contract_month` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contract_month").toString()));
      }
      if ((jsonObj.get("company_name") != null && !jsonObj.get("company_name").isJsonNull()) && !jsonObj.get("company_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `company_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("company_name").toString()));
      }
      if ((jsonObj.get("exchange") != null && !jsonObj.get("exchange").isJsonNull()) && !jsonObj.get("exchange").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `exchange` to be a primitive type in the JSON string but got `%s`", jsonObj.get("exchange").toString()));
      }
      if ((jsonObj.get("category") != null && !jsonObj.get("category").isJsonNull()) && !jsonObj.get("category").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `category` to be a primitive type in the JSON string but got `%s`", jsonObj.get("category").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ContractInfo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ContractInfo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ContractInfo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ContractInfo.class));

       return (TypeAdapter<T>) new TypeAdapter<ContractInfo>() {
           @Override
           public void write(JsonWriter out, ContractInfo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ContractInfo read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ContractInfo given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ContractInfo
   * @throws IOException if the JSON string is invalid with respect to ContractInfo
   */
  public static ContractInfo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ContractInfo.class);
  }

  /**
   * Convert an instance of ContractInfo to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

