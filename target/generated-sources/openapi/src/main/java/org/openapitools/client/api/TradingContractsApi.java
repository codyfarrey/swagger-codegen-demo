/*
 * IB REST API
 * The IB REST API reference documentation
 *
 * The version of the OpenAPI document: 2.13.0
 * Contact: api@interactivebrokers.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.AlgosResponse;
import org.openapitools.client.model.BondFiltersResponse;
import org.openapitools.client.model.ContractInfo;
import org.openapitools.client.model.ContractRules;
import org.openapitools.client.model.CurrencyPairsValueInner;
import org.openapitools.client.model.ErrorOnlyResponse;
import org.openapitools.client.model.ErrorResponse;
import org.openapitools.client.model.Features;
import org.openapitools.client.model.IserverContractConidInfoAndRulesGet200Response;
import org.openapitools.client.model.IserverContractRulesPostRequest;
import org.openapitools.client.model.IserverExchangerateGet200Response;
import org.openapitools.client.model.IserverSecdefSearchPostRequest;
import org.openapitools.client.model.IserverSecdefStrikesGet200Response;
import org.openapitools.client.model.SecDefInfoResponse;
import org.openapitools.client.model.SecdefSearchResponseInner;
import org.openapitools.client.model.StocksValueInner;
import org.openapitools.client.model.TradingScheduleInner;
import org.openapitools.client.model.TrsrvAllConidsGet200ResponseInner;
import org.openapitools.client.model.TrsrvSecDefResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TradingContractsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public TradingContractsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public TradingContractsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for iserverContractConidAlgosGet
     * @param conid  (required)
     * @param algos  (optional)
     * @param addDescription  (optional, default to 0)
     * @param addParams  (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of available algos and a description of their behavior. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverContractConidAlgosGetCall(String conid, String algos, String addDescription, String addParams, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/iserver/contract/{conid}/algos"
            .replace("{" + "conid" + "}", localVarApiClient.escapeString(conid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (algos != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("algos", algos));
        }

        if (addDescription != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("addDescription", addDescription));
        }

        if (addParams != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("addParams", addParams));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/plain; charset=utf-8",
            "application/json; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call iserverContractConidAlgosGetValidateBeforeCall(String conid, String algos, String addDescription, String addParams, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'conid' is set
        if (conid == null) {
            throw new ApiException("Missing the required parameter 'conid' when calling iserverContractConidAlgosGet(Async)");
        }

        return iserverContractConidAlgosGetCall(conid, algos, addDescription, addParams, _callback);

    }

    /**
     * Search Algo Params By Contract ID
     * Returns supported IB Algos for contract. A pre-flight request must be submitted before retrieving information
     * @param conid  (required)
     * @param algos  (optional)
     * @param addDescription  (optional, default to 0)
     * @param addParams  (optional, default to 0)
     * @return AlgosResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of available algos and a description of their behavior. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public AlgosResponse iserverContractConidAlgosGet(String conid, String algos, String addDescription, String addParams) throws ApiException {
        ApiResponse<AlgosResponse> localVarResp = iserverContractConidAlgosGetWithHttpInfo(conid, algos, addDescription, addParams);
        return localVarResp.getData();
    }

    /**
     * Search Algo Params By Contract ID
     * Returns supported IB Algos for contract. A pre-flight request must be submitted before retrieving information
     * @param conid  (required)
     * @param algos  (optional)
     * @param addDescription  (optional, default to 0)
     * @param addParams  (optional, default to 0)
     * @return ApiResponse&lt;AlgosResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of available algos and a description of their behavior. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AlgosResponse> iserverContractConidAlgosGetWithHttpInfo(String conid, String algos, String addDescription, String addParams) throws ApiException {
        okhttp3.Call localVarCall = iserverContractConidAlgosGetValidateBeforeCall(conid, algos, addDescription, addParams, null);
        Type localVarReturnType = new TypeToken<AlgosResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search Algo Params By Contract ID (asynchronously)
     * Returns supported IB Algos for contract. A pre-flight request must be submitted before retrieving information
     * @param conid  (required)
     * @param algos  (optional)
     * @param addDescription  (optional, default to 0)
     * @param addParams  (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of available algos and a description of their behavior. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverContractConidAlgosGetAsync(String conid, String algos, String addDescription, String addParams, final ApiCallback<AlgosResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = iserverContractConidAlgosGetValidateBeforeCall(conid, algos, addDescription, addParams, _callback);
        Type localVarReturnType = new TypeToken<AlgosResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for iserverContractConidInfoAndRulesGet
     * @param conid  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of available algos and a description of their behavior. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverContractConidInfoAndRulesGetCall(String conid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/iserver/contract/{conid}/info-and-rules"
            .replace("{" + "conid" + "}", localVarApiClient.escapeString(conid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "text/plain; charset=utf-8",
            "application/json; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call iserverContractConidInfoAndRulesGetValidateBeforeCall(String conid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'conid' is set
        if (conid == null) {
            throw new ApiException("Missing the required parameter 'conid' when calling iserverContractConidInfoAndRulesGet(Async)");
        }

        return iserverContractConidInfoAndRulesGetCall(conid, _callback);

    }

    /**
     * Contract Information And Rules By Contract ID
     * Requests full contract details for the given conid.
     * @param conid  (required)
     * @return IserverContractConidInfoAndRulesGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of available algos and a description of their behavior. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public IserverContractConidInfoAndRulesGet200Response iserverContractConidInfoAndRulesGet(String conid) throws ApiException {
        ApiResponse<IserverContractConidInfoAndRulesGet200Response> localVarResp = iserverContractConidInfoAndRulesGetWithHttpInfo(conid);
        return localVarResp.getData();
    }

    /**
     * Contract Information And Rules By Contract ID
     * Requests full contract details for the given conid.
     * @param conid  (required)
     * @return ApiResponse&lt;IserverContractConidInfoAndRulesGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of available algos and a description of their behavior. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IserverContractConidInfoAndRulesGet200Response> iserverContractConidInfoAndRulesGetWithHttpInfo(String conid) throws ApiException {
        okhttp3.Call localVarCall = iserverContractConidInfoAndRulesGetValidateBeforeCall(conid, null);
        Type localVarReturnType = new TypeToken<IserverContractConidInfoAndRulesGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Contract Information And Rules By Contract ID (asynchronously)
     * Requests full contract details for the given conid.
     * @param conid  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of available algos and a description of their behavior. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverContractConidInfoAndRulesGetAsync(String conid, final ApiCallback<IserverContractConidInfoAndRulesGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = iserverContractConidInfoAndRulesGetValidateBeforeCall(conid, _callback);
        Type localVarReturnType = new TypeToken<IserverContractConidInfoAndRulesGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for iserverContractConidInfoGet
     * @param conid  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of available algos and a description of their behavior. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverContractConidInfoGetCall(String conid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/iserver/contract/{conid}/info"
            .replace("{" + "conid" + "}", localVarApiClient.escapeString(conid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "text/plain; charset=utf-8",
            "application/json; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call iserverContractConidInfoGetValidateBeforeCall(String conid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'conid' is set
        if (conid == null) {
            throw new ApiException("Missing the required parameter 'conid' when calling iserverContractConidInfoGet(Async)");
        }

        return iserverContractConidInfoGetCall(conid, _callback);

    }

    /**
     * Contract Information By Contract ID
     * Requests full contract details for the given conid.
     * @param conid  (required)
     * @return ContractInfo
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of available algos and a description of their behavior. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ContractInfo iserverContractConidInfoGet(String conid) throws ApiException {
        ApiResponse<ContractInfo> localVarResp = iserverContractConidInfoGetWithHttpInfo(conid);
        return localVarResp.getData();
    }

    /**
     * Contract Information By Contract ID
     * Requests full contract details for the given conid.
     * @param conid  (required)
     * @return ApiResponse&lt;ContractInfo&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of available algos and a description of their behavior. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ContractInfo> iserverContractConidInfoGetWithHttpInfo(String conid) throws ApiException {
        okhttp3.Call localVarCall = iserverContractConidInfoGetValidateBeforeCall(conid, null);
        Type localVarReturnType = new TypeToken<ContractInfo>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Contract Information By Contract ID (asynchronously)
     * Requests full contract details for the given conid.
     * @param conid  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of available algos and a description of their behavior. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverContractConidInfoGetAsync(String conid, final ApiCallback<ContractInfo> _callback) throws ApiException {

        okhttp3.Call localVarCall = iserverContractConidInfoGetValidateBeforeCall(conid, _callback);
        Type localVarReturnType = new TypeToken<ContractInfo>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for iserverContractRulesPost
     * @param iserverContractRulesPostRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of objects detailing contract information. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverContractRulesPostCall(IserverContractRulesPostRequest iserverContractRulesPostRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = iserverContractRulesPostRequest;

        // create path and map variables
        String localVarPath = "/iserver/contract/rules";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "text/plain; charset=utf-8",
            "application/json; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call iserverContractRulesPostValidateBeforeCall(IserverContractRulesPostRequest iserverContractRulesPostRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'iserverContractRulesPostRequest' is set
        if (iserverContractRulesPostRequest == null) {
            throw new ApiException("Missing the required parameter 'iserverContractRulesPostRequest' when calling iserverContractRulesPost(Async)");
        }

        return iserverContractRulesPostCall(iserverContractRulesPostRequest, _callback);

    }

    /**
     * Search Contract Rules
     * Returns trading related rules for a specific contract and side.
     * @param iserverContractRulesPostRequest  (required)
     * @return ContractRules
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of objects detailing contract information. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ContractRules iserverContractRulesPost(IserverContractRulesPostRequest iserverContractRulesPostRequest) throws ApiException {
        ApiResponse<ContractRules> localVarResp = iserverContractRulesPostWithHttpInfo(iserverContractRulesPostRequest);
        return localVarResp.getData();
    }

    /**
     * Search Contract Rules
     * Returns trading related rules for a specific contract and side.
     * @param iserverContractRulesPostRequest  (required)
     * @return ApiResponse&lt;ContractRules&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of objects detailing contract information. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ContractRules> iserverContractRulesPostWithHttpInfo(IserverContractRulesPostRequest iserverContractRulesPostRequest) throws ApiException {
        okhttp3.Call localVarCall = iserverContractRulesPostValidateBeforeCall(iserverContractRulesPostRequest, null);
        Type localVarReturnType = new TypeToken<ContractRules>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search Contract Rules (asynchronously)
     * Returns trading related rules for a specific contract and side.
     * @param iserverContractRulesPostRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of objects detailing contract information. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverContractRulesPostAsync(IserverContractRulesPostRequest iserverContractRulesPostRequest, final ApiCallback<ContractRules> _callback) throws ApiException {

        okhttp3.Call localVarCall = iserverContractRulesPostValidateBeforeCall(iserverContractRulesPostRequest, _callback);
        Type localVarReturnType = new TypeToken<ContractRules>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for iserverCurrencyPairsGet
     * @param currency  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of valid forex pairs for the given currency. The currency can apply as both the target or base currency. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverCurrencyPairsGetCall(String currency, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/iserver/currency/pairs";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (currency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency", currency));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/json; charset=utf-8",
            "text/plain; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call iserverCurrencyPairsGetValidateBeforeCall(String currency, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'currency' is set
        if (currency == null) {
            throw new ApiException("Missing the required parameter 'currency' when calling iserverCurrencyPairsGet(Async)");
        }

        return iserverCurrencyPairsGetCall(currency, _callback);

    }

    /**
     * 
     * Obtains available currency pairs corresponding to the given target currency.
     * @param currency  (required)
     * @return Map&lt;String, List&lt;CurrencyPairsValueInner&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of valid forex pairs for the given currency. The currency can apply as both the target or base currency. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public Map<String, List<CurrencyPairsValueInner>> iserverCurrencyPairsGet(String currency) throws ApiException {
        ApiResponse<Map<String, List<CurrencyPairsValueInner>>> localVarResp = iserverCurrencyPairsGetWithHttpInfo(currency);
        return localVarResp.getData();
    }

    /**
     * 
     * Obtains available currency pairs corresponding to the given target currency.
     * @param currency  (required)
     * @return ApiResponse&lt;Map&lt;String, List&lt;CurrencyPairsValueInner&gt;&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of valid forex pairs for the given currency. The currency can apply as both the target or base currency. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Map<String, List<CurrencyPairsValueInner>>> iserverCurrencyPairsGetWithHttpInfo(String currency) throws ApiException {
        okhttp3.Call localVarCall = iserverCurrencyPairsGetValidateBeforeCall(currency, null);
        Type localVarReturnType = new TypeToken<Map<String, List<CurrencyPairsValueInner>>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Obtains available currency pairs corresponding to the given target currency.
     * @param currency  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of valid forex pairs for the given currency. The currency can apply as both the target or base currency. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverCurrencyPairsGetAsync(String currency, final ApiCallback<Map<String, List<CurrencyPairsValueInner>>> _callback) throws ApiException {

        okhttp3.Call localVarCall = iserverCurrencyPairsGetValidateBeforeCall(currency, _callback);
        Type localVarReturnType = new TypeToken<Map<String, List<CurrencyPairsValueInner>>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for iserverExchangerateGet
     * @param target  (required)
     * @param source  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful requests return the currency exchange rate of the target currency value divided by the source currency. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverExchangerateGetCall(String target, String source, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/iserver/exchangerate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (target != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("target", target));
        }

        if (source != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("source", source));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/json; charset=utf-8",
            "text/plain; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call iserverExchangerateGetValidateBeforeCall(String target, String source, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'target' is set
        if (target == null) {
            throw new ApiException("Missing the required parameter 'target' when calling iserverExchangerateGet(Async)");
        }

        // verify the required parameter 'source' is set
        if (source == null) {
            throw new ApiException("Missing the required parameter 'source' when calling iserverExchangerateGet(Async)");
        }

        return iserverExchangerateGetCall(target, source, _callback);

    }

    /**
     * Currency Exchange Rate
     * Obtains the exchange rates of the currency pair.
     * @param target  (required)
     * @param source  (required)
     * @return IserverExchangerateGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful requests return the currency exchange rate of the target currency value divided by the source currency. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public IserverExchangerateGet200Response iserverExchangerateGet(String target, String source) throws ApiException {
        ApiResponse<IserverExchangerateGet200Response> localVarResp = iserverExchangerateGetWithHttpInfo(target, source);
        return localVarResp.getData();
    }

    /**
     * Currency Exchange Rate
     * Obtains the exchange rates of the currency pair.
     * @param target  (required)
     * @param source  (required)
     * @return ApiResponse&lt;IserverExchangerateGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful requests return the currency exchange rate of the target currency value divided by the source currency. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IserverExchangerateGet200Response> iserverExchangerateGetWithHttpInfo(String target, String source) throws ApiException {
        okhttp3.Call localVarCall = iserverExchangerateGetValidateBeforeCall(target, source, null);
        Type localVarReturnType = new TypeToken<IserverExchangerateGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Currency Exchange Rate (asynchronously)
     * Obtains the exchange rates of the currency pair.
     * @param target  (required)
     * @param source  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful requests return the currency exchange rate of the target currency value divided by the source currency. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverExchangerateGetAsync(String target, String source, final ApiCallback<IserverExchangerateGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = iserverExchangerateGetValidateBeforeCall(target, source, _callback);
        Type localVarReturnType = new TypeToken<IserverExchangerateGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for iserverSecdefBondFiltersGet
     * @param symbol  (required)
     * @param issueId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful requests return the currency exchange rate of the target currency value divided by the source currency. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverSecdefBondFiltersGetCall(String symbol, String issueId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/iserver/secdef/bond-filters";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (issueId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("issueId", issueId));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/plain; charset=utf-8",
            "application/json; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call iserverSecdefBondFiltersGetValidateBeforeCall(String symbol, String issueId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'symbol' is set
        if (symbol == null) {
            throw new ApiException("Missing the required parameter 'symbol' when calling iserverSecdefBondFiltersGet(Async)");
        }

        // verify the required parameter 'issueId' is set
        if (issueId == null) {
            throw new ApiException("Missing the required parameter 'issueId' when calling iserverSecdefBondFiltersGet(Async)");
        }

        return iserverSecdefBondFiltersGetCall(symbol, issueId, _callback);

    }

    /**
     * Search Bond Filter Information
     * Request a list of filters relating to a given Bond issuerID. The issuerId is retrieved from /iserver/secdef/search and can be used in /iserver/secdef/info?issuerId&#x3D;{issuerId} for retrieving conIds.
     * @param symbol  (required)
     * @param issueId  (required)
     * @return BondFiltersResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful requests return the currency exchange rate of the target currency value divided by the source currency. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public BondFiltersResponse iserverSecdefBondFiltersGet(String symbol, String issueId) throws ApiException {
        ApiResponse<BondFiltersResponse> localVarResp = iserverSecdefBondFiltersGetWithHttpInfo(symbol, issueId);
        return localVarResp.getData();
    }

    /**
     * Search Bond Filter Information
     * Request a list of filters relating to a given Bond issuerID. The issuerId is retrieved from /iserver/secdef/search and can be used in /iserver/secdef/info?issuerId&#x3D;{issuerId} for retrieving conIds.
     * @param symbol  (required)
     * @param issueId  (required)
     * @return ApiResponse&lt;BondFiltersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful requests return the currency exchange rate of the target currency value divided by the source currency. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BondFiltersResponse> iserverSecdefBondFiltersGetWithHttpInfo(String symbol, String issueId) throws ApiException {
        okhttp3.Call localVarCall = iserverSecdefBondFiltersGetValidateBeforeCall(symbol, issueId, null);
        Type localVarReturnType = new TypeToken<BondFiltersResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search Bond Filter Information (asynchronously)
     * Request a list of filters relating to a given Bond issuerID. The issuerId is retrieved from /iserver/secdef/search and can be used in /iserver/secdef/info?issuerId&#x3D;{issuerId} for retrieving conIds.
     * @param symbol  (required)
     * @param issueId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful requests return the currency exchange rate of the target currency value divided by the source currency. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverSecdefBondFiltersGetAsync(String symbol, String issueId, final ApiCallback<BondFiltersResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = iserverSecdefBondFiltersGetValidateBeforeCall(symbol, issueId, _callback);
        Type localVarReturnType = new TypeToken<BondFiltersResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for iserverSecdefInfoGet
     * @param conid  (optional)
     * @param sectype  (optional)
     * @param month  (optional)
     * @param exchange  (optional)
     * @param strike  (optional)
     * @param right  (optional)
     * @param issuerId  (optional)
     * @param filters  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverSecdefInfoGetCall(String conid, Object sectype, Object month, Object exchange, Object strike, String right, String issuerId, Object filters, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/iserver/secdef/info";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (conid != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("conid", conid));
        }

        if (sectype != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sectype", sectype));
        }

        if (month != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("month", month));
        }

        if (exchange != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exchange", exchange));
        }

        if (strike != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("strike", strike));
        }

        if (right != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("right", right));
        }

        if (issuerId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("issuerId", issuerId));
        }

        if (filters != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filters", filters));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/json; charset=utf-8",
            "text/plain; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call iserverSecdefInfoGetValidateBeforeCall(String conid, Object sectype, Object month, Object exchange, Object strike, String right, String issuerId, Object filters, final ApiCallback _callback) throws ApiException {
        return iserverSecdefInfoGetCall(conid, sectype, month, exchange, strike, right, issuerId, filters, _callback);

    }

    /**
     * SecDef Info
     * SecDef info
     * @param conid  (optional)
     * @param sectype  (optional)
     * @param month  (optional)
     * @param exchange  (optional)
     * @param strike  (optional)
     * @param right  (optional)
     * @param issuerId  (optional)
     * @param filters  (optional)
     * @return SecDefInfoResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public SecDefInfoResponse iserverSecdefInfoGet(String conid, Object sectype, Object month, Object exchange, Object strike, String right, String issuerId, Object filters) throws ApiException {
        ApiResponse<SecDefInfoResponse> localVarResp = iserverSecdefInfoGetWithHttpInfo(conid, sectype, month, exchange, strike, right, issuerId, filters);
        return localVarResp.getData();
    }

    /**
     * SecDef Info
     * SecDef info
     * @param conid  (optional)
     * @param sectype  (optional)
     * @param month  (optional)
     * @param exchange  (optional)
     * @param strike  (optional)
     * @param right  (optional)
     * @param issuerId  (optional)
     * @param filters  (optional)
     * @return ApiResponse&lt;SecDefInfoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SecDefInfoResponse> iserverSecdefInfoGetWithHttpInfo(String conid, Object sectype, Object month, Object exchange, Object strike, String right, String issuerId, Object filters) throws ApiException {
        okhttp3.Call localVarCall = iserverSecdefInfoGetValidateBeforeCall(conid, sectype, month, exchange, strike, right, issuerId, filters, null);
        Type localVarReturnType = new TypeToken<SecDefInfoResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * SecDef Info (asynchronously)
     * SecDef info
     * @param conid  (optional)
     * @param sectype  (optional)
     * @param month  (optional)
     * @param exchange  (optional)
     * @param strike  (optional)
     * @param right  (optional)
     * @param issuerId  (optional)
     * @param filters  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverSecdefInfoGetAsync(String conid, Object sectype, Object month, Object exchange, Object strike, String right, String issuerId, Object filters, final ApiCallback<SecDefInfoResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = iserverSecdefInfoGetValidateBeforeCall(conid, sectype, month, exchange, strike, right, issuerId, filters, _callback);
        Type localVarReturnType = new TypeToken<SecDefInfoResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for iserverSecdefSearchGet
     * @param symbol  (optional)
     * @param secType Available underlying security types:   * &#x60;STK&#x60; - Represents an underlying as a Stock security type.   * &#x60;IND&#x60; - Represents an underlying as an Index security type.   * &#x60;BOND&#x60; - Represents an underlying as a Bond security type.  (optional, default to STK)
     * @param name  (optional)
     * @param more  (optional)
     * @param fund  (optional)
     * @param fundFamilyConidEx  (optional)
     * @param pattern  (optional)
     * @param referrer  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of objects detailing contract information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverSecdefSearchGetCall(String symbol, String secType, Boolean name, Boolean more, Boolean fund, String fundFamilyConidEx, Boolean pattern, String referrer, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/iserver/secdef/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (secType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secType", secType));
        }

        if (name != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("name", name));
        }

        if (more != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("more", more));
        }

        if (fund != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fund", fund));
        }

        if (fundFamilyConidEx != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fundFamilyConidEx", fundFamilyConidEx));
        }

        if (pattern != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pattern", pattern));
        }

        if (referrer != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("referrer", referrer));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/json; charset=utf-8",
            "text/plain; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call iserverSecdefSearchGetValidateBeforeCall(String symbol, String secType, Boolean name, Boolean more, Boolean fund, String fundFamilyConidEx, Boolean pattern, String referrer, final ApiCallback _callback) throws ApiException {
        return iserverSecdefSearchGetCall(symbol, secType, name, more, fund, fundFamilyConidEx, pattern, referrer, _callback);

    }

    /**
     * Returns A List Of Contracts Based On Symbol.
     * Returns a list of contracts based on the search symbol provided as a query param.
     * @param symbol  (optional)
     * @param secType Available underlying security types:   * &#x60;STK&#x60; - Represents an underlying as a Stock security type.   * &#x60;IND&#x60; - Represents an underlying as an Index security type.   * &#x60;BOND&#x60; - Represents an underlying as a Bond security type.  (optional, default to STK)
     * @param name  (optional)
     * @param more  (optional)
     * @param fund  (optional)
     * @param fundFamilyConidEx  (optional)
     * @param pattern  (optional)
     * @param referrer  (optional)
     * @return List&lt;SecdefSearchResponseInner&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of objects detailing contract information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public List<SecdefSearchResponseInner> iserverSecdefSearchGet(String symbol, String secType, Boolean name, Boolean more, Boolean fund, String fundFamilyConidEx, Boolean pattern, String referrer) throws ApiException {
        ApiResponse<List<SecdefSearchResponseInner>> localVarResp = iserverSecdefSearchGetWithHttpInfo(symbol, secType, name, more, fund, fundFamilyConidEx, pattern, referrer);
        return localVarResp.getData();
    }

    /**
     * Returns A List Of Contracts Based On Symbol.
     * Returns a list of contracts based on the search symbol provided as a query param.
     * @param symbol  (optional)
     * @param secType Available underlying security types:   * &#x60;STK&#x60; - Represents an underlying as a Stock security type.   * &#x60;IND&#x60; - Represents an underlying as an Index security type.   * &#x60;BOND&#x60; - Represents an underlying as a Bond security type.  (optional, default to STK)
     * @param name  (optional)
     * @param more  (optional)
     * @param fund  (optional)
     * @param fundFamilyConidEx  (optional)
     * @param pattern  (optional)
     * @param referrer  (optional)
     * @return ApiResponse&lt;List&lt;SecdefSearchResponseInner&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of objects detailing contract information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<SecdefSearchResponseInner>> iserverSecdefSearchGetWithHttpInfo(String symbol, String secType, Boolean name, Boolean more, Boolean fund, String fundFamilyConidEx, Boolean pattern, String referrer) throws ApiException {
        okhttp3.Call localVarCall = iserverSecdefSearchGetValidateBeforeCall(symbol, secType, name, more, fund, fundFamilyConidEx, pattern, referrer, null);
        Type localVarReturnType = new TypeToken<List<SecdefSearchResponseInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Returns A List Of Contracts Based On Symbol. (asynchronously)
     * Returns a list of contracts based on the search symbol provided as a query param.
     * @param symbol  (optional)
     * @param secType Available underlying security types:   * &#x60;STK&#x60; - Represents an underlying as a Stock security type.   * &#x60;IND&#x60; - Represents an underlying as an Index security type.   * &#x60;BOND&#x60; - Represents an underlying as a Bond security type.  (optional, default to STK)
     * @param name  (optional)
     * @param more  (optional)
     * @param fund  (optional)
     * @param fundFamilyConidEx  (optional)
     * @param pattern  (optional)
     * @param referrer  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of objects detailing contract information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverSecdefSearchGetAsync(String symbol, String secType, Boolean name, Boolean more, Boolean fund, String fundFamilyConidEx, Boolean pattern, String referrer, final ApiCallback<List<SecdefSearchResponseInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = iserverSecdefSearchGetValidateBeforeCall(symbol, secType, name, more, fund, fundFamilyConidEx, pattern, referrer, _callback);
        Type localVarReturnType = new TypeToken<List<SecdefSearchResponseInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for iserverSecdefSearchPost
     * @param iserverSecdefSearchPostRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of objects detailing contract information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverSecdefSearchPostCall(IserverSecdefSearchPostRequest iserverSecdefSearchPostRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = iserverSecdefSearchPostRequest;

        // create path and map variables
        String localVarPath = "/iserver/secdef/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "application/json; charset=utf-8",
            "text/plain; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call iserverSecdefSearchPostValidateBeforeCall(IserverSecdefSearchPostRequest iserverSecdefSearchPostRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'iserverSecdefSearchPostRequest' is set
        if (iserverSecdefSearchPostRequest == null) {
            throw new ApiException("Missing the required parameter 'iserverSecdefSearchPostRequest' when calling iserverSecdefSearchPost(Async)");
        }

        return iserverSecdefSearchPostCall(iserverSecdefSearchPostRequest, _callback);

    }

    /**
     * Returns A List Of Contracts Based On Symbol.
     * Returns a list of contracts based on the search symbol provided as a query param.
     * @param iserverSecdefSearchPostRequest  (required)
     * @return List&lt;SecdefSearchResponseInner&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of objects detailing contract information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public List<SecdefSearchResponseInner> iserverSecdefSearchPost(IserverSecdefSearchPostRequest iserverSecdefSearchPostRequest) throws ApiException {
        ApiResponse<List<SecdefSearchResponseInner>> localVarResp = iserverSecdefSearchPostWithHttpInfo(iserverSecdefSearchPostRequest);
        return localVarResp.getData();
    }

    /**
     * Returns A List Of Contracts Based On Symbol.
     * Returns a list of contracts based on the search symbol provided as a query param.
     * @param iserverSecdefSearchPostRequest  (required)
     * @return ApiResponse&lt;List&lt;SecdefSearchResponseInner&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of objects detailing contract information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<SecdefSearchResponseInner>> iserverSecdefSearchPostWithHttpInfo(IserverSecdefSearchPostRequest iserverSecdefSearchPostRequest) throws ApiException {
        okhttp3.Call localVarCall = iserverSecdefSearchPostValidateBeforeCall(iserverSecdefSearchPostRequest, null);
        Type localVarReturnType = new TypeToken<List<SecdefSearchResponseInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Returns A List Of Contracts Based On Symbol. (asynchronously)
     * Returns a list of contracts based on the search symbol provided as a query param.
     * @param iserverSecdefSearchPostRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of objects detailing contract information. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverSecdefSearchPostAsync(IserverSecdefSearchPostRequest iserverSecdefSearchPostRequest, final ApiCallback<List<SecdefSearchResponseInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = iserverSecdefSearchPostValidateBeforeCall(iserverSecdefSearchPostRequest, _callback);
        Type localVarReturnType = new TypeToken<List<SecdefSearchResponseInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for iserverSecdefStrikesGet
     * @param conid  (required)
     * @param sectype  (required)
     * @param month  (required)
     * @param exchange  (optional, default to SMART)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverSecdefStrikesGetCall(String conid, String sectype, String month, String exchange, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/iserver/secdef/strikes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (conid != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("conid", conid));
        }

        if (sectype != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sectype", sectype));
        }

        if (month != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("month", month));
        }

        if (exchange != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exchange", exchange));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/json; charset=utf-8",
            "text/plain; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call iserverSecdefStrikesGetValidateBeforeCall(String conid, String sectype, String month, String exchange, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'conid' is set
        if (conid == null) {
            throw new ApiException("Missing the required parameter 'conid' when calling iserverSecdefStrikesGet(Async)");
        }

        // verify the required parameter 'sectype' is set
        if (sectype == null) {
            throw new ApiException("Missing the required parameter 'sectype' when calling iserverSecdefStrikesGet(Async)");
        }

        // verify the required parameter 'month' is set
        if (month == null) {
            throw new ApiException("Missing the required parameter 'month' when calling iserverSecdefStrikesGet(Async)");
        }

        return iserverSecdefStrikesGetCall(conid, sectype, month, exchange, _callback);

    }

    /**
     * Get Strikes
     * strikes
     * @param conid  (required)
     * @param sectype  (required)
     * @param month  (required)
     * @param exchange  (optional, default to SMART)
     * @return IserverSecdefStrikesGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public IserverSecdefStrikesGet200Response iserverSecdefStrikesGet(String conid, String sectype, String month, String exchange) throws ApiException {
        ApiResponse<IserverSecdefStrikesGet200Response> localVarResp = iserverSecdefStrikesGetWithHttpInfo(conid, sectype, month, exchange);
        return localVarResp.getData();
    }

    /**
     * Get Strikes
     * strikes
     * @param conid  (required)
     * @param sectype  (required)
     * @param month  (required)
     * @param exchange  (optional, default to SMART)
     * @return ApiResponse&lt;IserverSecdefStrikesGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IserverSecdefStrikesGet200Response> iserverSecdefStrikesGetWithHttpInfo(String conid, String sectype, String month, String exchange) throws ApiException {
        okhttp3.Call localVarCall = iserverSecdefStrikesGetValidateBeforeCall(conid, sectype, month, exchange, null);
        Type localVarReturnType = new TypeToken<IserverSecdefStrikesGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Strikes (asynchronously)
     * strikes
     * @param conid  (required)
     * @param sectype  (required)
     * @param month  (required)
     * @param exchange  (optional, default to SMART)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call iserverSecdefStrikesGetAsync(String conid, String sectype, String month, String exchange, final ApiCallback<IserverSecdefStrikesGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = iserverSecdefStrikesGetValidateBeforeCall(conid, sectype, month, exchange, _callback);
        Type localVarReturnType = new TypeToken<IserverSecdefStrikesGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for trsrvAllConidsGet
     * @param exchange  (required)
     * @param assetClass  (optional, default to STK)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call trsrvAllConidsGetCall(String exchange, Object assetClass, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/trsrv/all-conids";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (exchange != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exchange", exchange));
        }

        if (assetClass != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("assetClass", assetClass));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/plain; charset=utf-8",
            "application/json; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call trsrvAllConidsGetValidateBeforeCall(String exchange, Object assetClass, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'exchange' is set
        if (exchange == null) {
            throw new ApiException("Missing the required parameter 'exchange' when calling trsrvAllConidsGet(Async)");
        }

        return trsrvAllConidsGetCall(exchange, assetClass, _callback);

    }

    /**
     * All Conids By Exchange
     * Send out a request to retrieve all contracts made available on a requested exchange. This returns all contracts that are tradable on the exchange, even those that are not using the exchange as their primary listing.
     * @param exchange  (required)
     * @param assetClass  (optional, default to STK)
     * @return List&lt;TrsrvAllConidsGet200ResponseInner&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public List<TrsrvAllConidsGet200ResponseInner> trsrvAllConidsGet(String exchange, Object assetClass) throws ApiException {
        ApiResponse<List<TrsrvAllConidsGet200ResponseInner>> localVarResp = trsrvAllConidsGetWithHttpInfo(exchange, assetClass);
        return localVarResp.getData();
    }

    /**
     * All Conids By Exchange
     * Send out a request to retrieve all contracts made available on a requested exchange. This returns all contracts that are tradable on the exchange, even those that are not using the exchange as their primary listing.
     * @param exchange  (required)
     * @param assetClass  (optional, default to STK)
     * @return ApiResponse&lt;List&lt;TrsrvAllConidsGet200ResponseInner&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TrsrvAllConidsGet200ResponseInner>> trsrvAllConidsGetWithHttpInfo(String exchange, Object assetClass) throws ApiException {
        okhttp3.Call localVarCall = trsrvAllConidsGetValidateBeforeCall(exchange, assetClass, null);
        Type localVarReturnType = new TypeToken<List<TrsrvAllConidsGet200ResponseInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * All Conids By Exchange (asynchronously)
     * Send out a request to retrieve all contracts made available on a requested exchange. This returns all contracts that are tradable on the exchange, even those that are not using the exchange as their primary listing.
     * @param exchange  (required)
     * @param assetClass  (optional, default to STK)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call trsrvAllConidsGetAsync(String exchange, Object assetClass, final ApiCallback<List<TrsrvAllConidsGet200ResponseInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = trsrvAllConidsGetValidateBeforeCall(exchange, assetClass, _callback);
        Type localVarReturnType = new TypeToken<List<TrsrvAllConidsGet200ResponseInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for trsrvFuturesGet
     * @param symbols  (required)
     * @param exchange  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call trsrvFuturesGetCall(String symbols, Object exchange, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/trsrv/futures";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbols != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbols", symbols));
        }

        if (exchange != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exchange", exchange));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/plain; charset=utf-8",
            "application/json; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call trsrvFuturesGetValidateBeforeCall(String symbols, Object exchange, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'symbols' is set
        if (symbols == null) {
            throw new ApiException("Missing the required parameter 'symbols' when calling trsrvFuturesGet(Async)");
        }

        return trsrvFuturesGetCall(symbols, exchange, _callback);

    }

    /**
     * Future  Security Definition By Symbol
     * Returns a list of non-expired future contracts for given symbol(s)
     * @param symbols  (required)
     * @param exchange  (optional)
     * @return Features
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public Features trsrvFuturesGet(String symbols, Object exchange) throws ApiException {
        ApiResponse<Features> localVarResp = trsrvFuturesGetWithHttpInfo(symbols, exchange);
        return localVarResp.getData();
    }

    /**
     * Future  Security Definition By Symbol
     * Returns a list of non-expired future contracts for given symbol(s)
     * @param symbols  (required)
     * @param exchange  (optional)
     * @return ApiResponse&lt;Features&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Features> trsrvFuturesGetWithHttpInfo(String symbols, Object exchange) throws ApiException {
        okhttp3.Call localVarCall = trsrvFuturesGetValidateBeforeCall(symbols, exchange, null);
        Type localVarReturnType = new TypeToken<Features>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Future  Security Definition By Symbol (asynchronously)
     * Returns a list of non-expired future contracts for given symbol(s)
     * @param symbols  (required)
     * @param exchange  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call trsrvFuturesGetAsync(String symbols, Object exchange, final ApiCallback<Features> _callback) throws ApiException {

        okhttp3.Call localVarCall = trsrvFuturesGetValidateBeforeCall(symbols, exchange, _callback);
        Type localVarReturnType = new TypeToken<Features>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for trsrvSecdefGet
     * @param conids  (required)
     * @param UNKNOWN_PARAMETER_NAME  (optional)
     * @param UNKNOWN_PARAMETER_NAME2  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call trsrvSecdefGetCall(String conids,  UNKNOWN_PARAMETER_NAME,  UNKNOWN_PARAMETER_NAME2, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/trsrv/secdef";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (conids != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("conids", conids));
        }

        if (UNKNOWN_PARAMETER_NAME != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("criteria", UNKNOWN_PARAMETER_NAME));
        }

        if (UNKNOWN_PARAMETER_NAME2 != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bondp", UNKNOWN_PARAMETER_NAME2));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/json; charset=utf-8",
            "text/plain; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call trsrvSecdefGetValidateBeforeCall(String conids,  UNKNOWN_PARAMETER_NAME,  UNKNOWN_PARAMETER_NAME2, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'conids' is set
        if (conids == null) {
            throw new ApiException("Missing the required parameter 'conids' when calling trsrvSecdefGet(Async)");
        }

        return trsrvSecdefGetCall(conids, UNKNOWN_PARAMETER_NAME, UNKNOWN_PARAMETER_NAME2, _callback);

    }

    /**
     * Search The Security Definition By Contract ID
     * Returns a list of security definitions for the given conids.
     * @param conids  (required)
     * @param UNKNOWN_PARAMETER_NAME  (optional)
     * @param UNKNOWN_PARAMETER_NAME2  (optional)
     * @return TrsrvSecDefResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public TrsrvSecDefResponse trsrvSecdefGet(String conids,  UNKNOWN_PARAMETER_NAME,  UNKNOWN_PARAMETER_NAME2) throws ApiException {
        ApiResponse<TrsrvSecDefResponse> localVarResp = trsrvSecdefGetWithHttpInfo(conids, UNKNOWN_PARAMETER_NAME, UNKNOWN_PARAMETER_NAME2);
        return localVarResp.getData();
    }

    /**
     * Search The Security Definition By Contract ID
     * Returns a list of security definitions for the given conids.
     * @param conids  (required)
     * @param UNKNOWN_PARAMETER_NAME  (optional)
     * @param UNKNOWN_PARAMETER_NAME2  (optional)
     * @return ApiResponse&lt;TrsrvSecDefResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TrsrvSecDefResponse> trsrvSecdefGetWithHttpInfo(String conids,  UNKNOWN_PARAMETER_NAME,  UNKNOWN_PARAMETER_NAME2) throws ApiException {
        okhttp3.Call localVarCall = trsrvSecdefGetValidateBeforeCall(conids, UNKNOWN_PARAMETER_NAME, UNKNOWN_PARAMETER_NAME2, null);
        Type localVarReturnType = new TypeToken<TrsrvSecDefResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search The Security Definition By Contract ID (asynchronously)
     * Returns a list of security definitions for the given conids.
     * @param conids  (required)
     * @param UNKNOWN_PARAMETER_NAME  (optional)
     * @param UNKNOWN_PARAMETER_NAME2  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> no content </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call trsrvSecdefGetAsync(String conids,  UNKNOWN_PARAMETER_NAME,  UNKNOWN_PARAMETER_NAME2, final ApiCallback<TrsrvSecDefResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = trsrvSecdefGetValidateBeforeCall(conids, UNKNOWN_PARAMETER_NAME, UNKNOWN_PARAMETER_NAME2, _callback);
        Type localVarReturnType = new TypeToken<TrsrvSecDefResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for trsrvSecdefScheduleGet
     * @param assetClass  (required)
     * @param symbol  (required)
     * @param exchange  (optional)
     * @param exchangeFilter  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the trading schedule up to a month for the requested contract. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call trsrvSecdefScheduleGetCall(String assetClass, String symbol, String exchange, String exchangeFilter, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/trsrv/secdef/schedule";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (assetClass != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("assetClass", assetClass));
        }

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (exchange != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exchange", exchange));
        }

        if (exchangeFilter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exchangeFilter", exchangeFilter));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/json; charset=utf-8",
            "text/plain; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call trsrvSecdefScheduleGetValidateBeforeCall(String assetClass, String symbol, String exchange, String exchangeFilter, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'assetClass' is set
        if (assetClass == null) {
            throw new ApiException("Missing the required parameter 'assetClass' when calling trsrvSecdefScheduleGet(Async)");
        }

        // verify the required parameter 'symbol' is set
        if (symbol == null) {
            throw new ApiException("Missing the required parameter 'symbol' when calling trsrvSecdefScheduleGet(Async)");
        }

        return trsrvSecdefScheduleGetCall(assetClass, symbol, exchange, exchangeFilter, _callback);

    }

    /**
     * Trading Schedule By Symbol
     * Returns the trading schedule up to a month for the requested contract.
     * @param assetClass  (required)
     * @param symbol  (required)
     * @param exchange  (optional)
     * @param exchangeFilter  (optional)
     * @return List&lt;TradingScheduleInner&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the trading schedule up to a month for the requested contract. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public List<TradingScheduleInner> trsrvSecdefScheduleGet(String assetClass, String symbol, String exchange, String exchangeFilter) throws ApiException {
        ApiResponse<List<TradingScheduleInner>> localVarResp = trsrvSecdefScheduleGetWithHttpInfo(assetClass, symbol, exchange, exchangeFilter);
        return localVarResp.getData();
    }

    /**
     * Trading Schedule By Symbol
     * Returns the trading schedule up to a month for the requested contract.
     * @param assetClass  (required)
     * @param symbol  (required)
     * @param exchange  (optional)
     * @param exchangeFilter  (optional)
     * @return ApiResponse&lt;List&lt;TradingScheduleInner&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the trading schedule up to a month for the requested contract. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TradingScheduleInner>> trsrvSecdefScheduleGetWithHttpInfo(String assetClass, String symbol, String exchange, String exchangeFilter) throws ApiException {
        okhttp3.Call localVarCall = trsrvSecdefScheduleGetValidateBeforeCall(assetClass, symbol, exchange, exchangeFilter, null);
        Type localVarReturnType = new TypeToken<List<TradingScheduleInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Trading Schedule By Symbol (asynchronously)
     * Returns the trading schedule up to a month for the requested contract.
     * @param assetClass  (required)
     * @param symbol  (required)
     * @param exchange  (optional)
     * @param exchangeFilter  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the trading schedule up to a month for the requested contract. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call trsrvSecdefScheduleGetAsync(String assetClass, String symbol, String exchange, String exchangeFilter, final ApiCallback<List<TradingScheduleInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = trsrvSecdefScheduleGetValidateBeforeCall(assetClass, symbol, exchange, exchangeFilter, _callback);
        Type localVarReturnType = new TypeToken<List<TradingScheduleInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for trsrvStocksGet
     * @param symbols  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call trsrvStocksGetCall(String symbols, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://api.ibkr.com/v1/api", "https://api.ibkr.com/alpha/api" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/trsrv/stocks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbols != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbols", symbols));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/json; charset=utf-8",
            "text/plain; charset=utf-8"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call trsrvStocksGetValidateBeforeCall(String symbols, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'symbols' is set
        if (symbols == null) {
            throw new ApiException("Missing the required parameter 'symbols' when calling trsrvStocksGet(Async)");
        }

        return trsrvStocksGetCall(symbols, _callback);

    }

    /**
     * Stock Security Definition By Symbol
     * Returns an object contains all stock contracts for given symbol(s)
     * @param symbols  (required)
     * @return Map&lt;String, List&lt;StocksValueInner&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public Map<String, List<StocksValueInner>> trsrvStocksGet(String symbols) throws ApiException {
        ApiResponse<Map<String, List<StocksValueInner>>> localVarResp = trsrvStocksGetWithHttpInfo(symbols);
        return localVarResp.getData();
    }

    /**
     * Stock Security Definition By Symbol
     * Returns an object contains all stock contracts for given symbol(s)
     * @param symbols  (required)
     * @return ApiResponse&lt;Map&lt;String, List&lt;StocksValueInner&gt;&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Map<String, List<StocksValueInner>>> trsrvStocksGetWithHttpInfo(String symbols) throws ApiException {
        okhttp3.Call localVarCall = trsrvStocksGetValidateBeforeCall(symbols, null);
        Type localVarReturnType = new TypeToken<Map<String, List<StocksValueInner>>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Stock Security Definition By Symbol (asynchronously)
     * Returns an object contains all stock contracts for given symbol(s)
     * @param symbols  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response containing a contract&#39;s security definition. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access denied </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal server error, returned when incoming request cannot be processed. It can sometimes include subset of bad requests.  For example, wrong accountId passed and it can only be detected later in handling request. Error contains reason of the problem.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> service is unavailable. For example if request takes more than 10s due to some internal service unavailability,  request aborted and this status returned  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call trsrvStocksGetAsync(String symbols, final ApiCallback<Map<String, List<StocksValueInner>>> _callback) throws ApiException {

        okhttp3.Call localVarCall = trsrvStocksGetValidateBeforeCall(symbols, _callback);
        Type localVarReturnType = new TypeToken<Map<String, List<StocksValueInner>>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
